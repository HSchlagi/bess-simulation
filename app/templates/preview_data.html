{% extends "base.html" %}

{% block title %}Datenvorschau{% endblock %}

{% block content %}
<div class="container mx-auto px-4 py-8">
    <div class="mb-8">
        <h1 class="text-3xl font-bold text-gray-800 mb-4">
            <i class="fas fa-chart-line text-blue-600 mr-3"></i>
            Intelligente Datenvorschau
        </h1>
        <p class="text-gray-600">Betrachte und analysiere alle importierten Daten aus verschiedenen Quellen.</p>
    </div>

    <!-- Projekt- und Datenart-Auswahl -->
    <div class="bg-white rounded-lg shadow-md p-6 mb-6">
        <h2 class="text-xl font-semibold text-gray-800 mb-4">
            <i class="fas fa-filter text-green-600 mr-2"></i>
            Datenauswahl
        </h2>
        <div class="grid grid-cols-1 md:grid-cols-3 gap-4">
            <div>
                <label class="block text-sm font-medium text-gray-700 mb-2">Projekt</label>
                <select id="projectSelect" onchange="loadDataTypes()" class="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500">
                    <option value="">Projekt auswählen...</option>
                </select>
            </div>
            <div class="mb-4">
                <label class="block text-sm font-medium text-gray-700 mb-2">Datenart</label>
                <select id="dataTypeSelect" onchange="handleDataTypeChange()" class="w-full px-3 py-2 border border-gray-300 rounded-md">
                    <option value="">Bitte wählen...</option>
                    <!-- Optionen werden dynamisch über loadDataTypes() geladen -->
                </select>
            </div>
            <div>
                <label class="block text-sm font-medium text-gray-700 mb-2">Zeitraum</label>
                <select id="timeRangeSelect" onchange="handleTimeRangeChange()" class="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500" disabled>
                    <option value="all">Alle Daten</option>
                    <option value="week">Letzte Woche</option>
                    <option value="month">Letzter Monat</option>
                    <option value="year">Letztes Jahr</option>
                    <option value="custom">Benutzerdefiniert</option>
                </select>
            </div>
        </div>
        
        <!-- Benutzerdefinierter Zeitraum (versteckt) -->
        <div id="customTimeRange" class="mt-4 hidden">
            <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                <div>
                    <label class="block text-sm font-medium text-gray-700 mb-2">Von</label>
                    <input type="datetime-local" id="startDate" onchange="handleCustomDateChange()" class="w-full px-3 py-2 border border-gray-300 rounded-md">
                </div>
                <div>
                    <label class="block text-sm font-medium text-gray-700 mb-2">Bis</label>
                    <input type="datetime-local" id="endDate" onchange="handleCustomDateChange()" class="w-full px-3 py-2 border border-gray-300 rounded-md">
                </div>
            </div>
            <div class="mt-4 flex justify-end">
                <button onclick="loadDataPreview()" class="px-4 py-2 bg-blue-600 text-white rounded-md hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-500">
                    <i class="fas fa-search mr-2"></i>Daten laden
                </button>
            </div>
        </div>
    </div>

    <!-- Datenvorschau Container -->
    <div id="dataPreviewContainer" class="hidden">
        <!-- Datenart-spezifische Informationen -->
        <div id="dataTypeInfo" class="bg-blue-50 border border-blue-200 rounded-lg p-4 mb-6">
            <!-- Wird dynamisch gefüllt -->
        </div>

        <!-- Statistiken -->
        <div id="statisticsContainer" class="bg-white rounded-lg shadow-md p-6 mb-6">
            <h3 class="text-lg font-semibold text-gray-800 mb-4">
                <i class="fas fa-chart-bar text-purple-600 mr-2"></i>
                Statistiken
            </h3>
            <div id="statisticsGrid" class="grid grid-cols-2 md:grid-cols-4 gap-4">
                <!-- Wird dynamisch gefüllt -->
            </div>
        </div>

        <!-- Visualisierung -->
        <div class="bg-white rounded-lg shadow-md p-6 mb-6">
            <h3 class="text-lg font-semibold text-gray-800 mb-4">
                <i class="fas fa-chart-line text-green-600 mr-2"></i>
                Visualisierung
            </h3>
            <div class="h-96">
                <canvas id="dataChart"></canvas>
            </div>
        </div>

        <!-- Rohdaten -->
        <div class="bg-white rounded-lg shadow-md p-6">
            <div class="flex justify-between items-center mb-4">
                <h3 class="text-lg font-semibold text-gray-800">
                    <i class="fas fa-table text-orange-600 mr-2"></i>
                    Rohdaten
                </h3>
                <div class="flex items-center space-x-2">
                    <span class="text-sm text-gray-600">Zeige:</span>
                    <select id="rowsPerPage" onchange="updateDataTable()" class="text-sm border border-gray-300 rounded px-2 py-1">
                        <option value="10">10</option>
                        <option value="25" selected>25</option>
                        <option value="50">50</option>
                        <option value="100">100</option>
                    </select>
                    <span class="text-sm text-gray-600">Zeilen</span>
                </div>
            </div>
            
            <div class="overflow-x-auto">
                <table class="min-w-full divide-y divide-gray-200 text-sm">
                    <thead class="bg-gray-50">
                        <tr id="tableHeader">
                            <!-- Wird dynamisch gefüllt -->
                        </tr>
                    </thead>
                    <tbody id="dataTable" class="bg-white divide-y divide-gray-200">
                        <!-- Wird dynamisch gefüllt -->
                    </tbody>
                </table>
            </div>
            
            <!-- Paginierung -->
            <div class="flex justify-between items-center mt-4 pt-4 border-t border-gray-200">
                <div class="text-sm text-gray-600">
                    <span id="paginationInfo">Zeige 0 von 0 Einträgen</span>
                </div>
                <div class="flex space-x-2">
                    <button id="prevPage" onclick="changePage(-1)" 
                            class="px-3 py-1 text-sm bg-gray-200 hover:bg-gray-300 rounded disabled:opacity-50 disabled:cursor-not-allowed">
                        ← Vorherige
                    </button>
                    <span id="pageInfo" class="px-3 py-1 text-sm text-gray-600">Seite 1</span>
                    <button id="nextPage" onclick="changePage(1)" 
                            class="px-3 py-1 text-sm bg-gray-200 hover:bg-gray-300 rounded disabled:opacity-50 disabled:cursor-not-allowed">
                        Nächste →
                    </button>
                </div>
            </div>
        </div>
    </div>

    <!-- Keine Daten Nachricht -->
    <div id="noDataMessage" class="bg-yellow-50 border border-yellow-200 rounded-lg p-6 text-center">
        <i class="fas fa-info-circle text-yellow-600 text-3xl mb-4"></i>
        <h3 class="text-lg font-semibold text-yellow-800 mb-2">Keine Daten ausgewählt</h3>
        <p class="text-yellow-700">Wählen Sie ein Projekt und eine Datenart aus, um die Datenvorschau zu sehen.</p>
    </div>
</div>

<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<script>
let currentChart = null;
let currentData = [];
let currentPage = 1;
let rowsPerPage = 25;
let currentProjectId = null;
let currentDataType = null;

// Datenart-Konfiguration
const dataTypes = {
    'load_profile': {
        name: 'Lastprofile',
        icon: 'fas fa-chart-line',
        color: 'blue',
        unit: 'kW',
        description: 'Energieverbrauch und Lastdaten'
    },
    'solar_radiation': {
        name: 'Einstrahlung',
        icon: 'fas fa-sun',
        color: 'yellow',
        unit: 'W/m²',
        description: 'Sonnenstrahlung und Einstrahlungswerte'
    },
    'water_level': {
        name: 'Pegelstände',
        icon: 'fas fa-water',
        color: 'blue',
        unit: 'm',
        description: 'Wasserstände und Pegeldaten'
    },
    'pvsol_export': {
        name: 'PVSol Export',
        icon: 'fas fa-solar-panel',
        color: 'green',
        unit: 'kWh',
        description: 'PVSol Simulationsdaten'
    },
    'weather': {
        name: 'Wetterdaten',
        icon: 'fas fa-cloud',
        color: 'gray',
        unit: '°C',
        description: 'Temperatur, Luftfeuchtigkeit und Wetterdaten'
    },
    'wind': {
        name: 'Winddaten (GeoSphere)',
        icon: 'fas fa-wind',
        color: 'indigo',
        unit: 'kW',
        description: 'Windleistung und Windgeschwindigkeit (GeoSphere)'
    },
    'overlay': {
        name: 'Last & Erzeugung Overlay',
        icon: 'fas fa-layer-group',
        color: 'purple',
        unit: 'kW',
        description: 'Kombinierte Ansicht von Last, PV-Erzeugung und Wasserkraft'
    }
};

document.addEventListener('DOMContentLoaded', function() {
    loadProjects();
    // setupTimeRangeHandler() wird nicht mehr benötigt, da handleTimeRangeChange() direkt verwendet wird
});

function loadProjects() {
    fetch('/api/projects')
        .then(response => response.json())
        .then(projects => {
            const select = document.getElementById('projectSelect');
            select.innerHTML = '<option value="">Projekt auswählen...</option>';
            
            projects.forEach(project => {
                const option = document.createElement('option');
                option.value = project.id;
                option.textContent = project.name;
                select.appendChild(option);
            });
        })
        .catch(error => {
            console.error('Fehler beim Laden der Projekte:', error);
        });
}

function loadDataTypes() {
    const projectId = document.getElementById('projectSelect').value;
    const dataTypeSelect = document.getElementById('dataTypeSelect');
    const timeRangeSelect = document.getElementById('timeRangeSelect');
    
    if (!projectId) {
        dataTypeSelect.innerHTML = '<option value="">Datenart auswählen...</option>';
        dataTypeSelect.disabled = true;
        timeRangeSelect.disabled = true;
        hideDataPreview();
        return;
    }
    
    currentProjectId = projectId;
    
    // Alle verfügbaren Datenarten anzeigen
    dataTypeSelect.innerHTML = '<option value="">Bitte wählen...</option>';
    
    Object.entries(dataTypes).forEach(([key, config]) => {
        const option = document.createElement('option');
        option.value = key;
        option.textContent = config.name;
        dataTypeSelect.appendChild(option);
    });
    
    // Overlay ist jetzt bereits in dataTypes enthalten, daher keine manuelle Hinzufügung mehr nötig
    
    dataTypeSelect.disabled = false;
    timeRangeSelect.disabled = false;
    
    // Daten NICHT automatisch laden - Benutzer soll zuerst Datenart und Zeitraum wählen
}

function handleDataTypeChange() {
    const dataType = document.getElementById('dataTypeSelect').value;
    const timeRange = document.getElementById('timeRangeSelect').value;
    
    if (!dataType) {
        hideDataPreview();
        return;
    }
    
    // Nur automatisch laden wenn NICHT "Benutzerdefiniert" ausgewählt ist
    // Bei "Benutzerdefiniert" muss der Benutzer zuerst die Datumsfelder prüfen/anpassen
    if (timeRange !== 'custom') {
        loadDataPreview();
    } else {
        // Bei "Benutzerdefiniert": Prüfe ob Datumsfelder gefüllt sind
        const startDate = document.getElementById('startDate').value;
        const endDate = document.getElementById('endDate').value;
        if (startDate && endDate) {
            // Datumsfelder sind gefüllt, lade Daten
            loadDataPreview();
        } else {
            // Datumsfelder sind leer, zeige nur die Auswahl
            hideDataPreview();
        }
    }
}

function handleTimeRangeChange() {
    const timeRange = document.getElementById('timeRangeSelect').value;
    const customTimeRange = document.getElementById('customTimeRange');
    
    if (timeRange === 'custom') {
        customTimeRange.classList.remove('hidden');
        // Setze Standard-Datumsbereich (letzter Monat) nur wenn noch nicht gesetzt
        const startDateInput = document.getElementById('startDate');
        const endDateInput = document.getElementById('endDate');
        
        if (!startDateInput.value || !endDateInput.value) {
            const now = new Date();
            const lastMonth = new Date(now.getFullYear(), now.getMonth() - 1, now.getDate());
            const startDate = lastMonth.toISOString().slice(0, 16);
            const endDate = now.toISOString().slice(0, 16);
            
            startDateInput.value = startDate;
            endDateInput.value = endDate;
        }
        
        // Bei Wechsel zu "Benutzerdefiniert": Lade Daten nur wenn Datenart bereits ausgewählt
        const dataType = document.getElementById('dataTypeSelect').value;
        if (dataType && currentProjectId && startDateInput.value && endDateInput.value) {
            loadDataPreview();
        }
    } else {
        customTimeRange.classList.add('hidden');
        // Bei anderen Zeiträumen: Automatisch laden wenn Datenart bereits ausgewählt
        const dataType = document.getElementById('dataTypeSelect').value;
        if (dataType && currentProjectId) {
            loadDataPreview();
        }
    }
}

function loadDataPreview() {
    const dataType = document.getElementById('dataTypeSelect').value;
    const timeRange = document.getElementById('timeRangeSelect').value;
    
    if (!dataType || !currentProjectId) {
        hideDataPreview();
        hideLoadingIndicator();
        return;
    }
    
    currentDataType = dataType;
    
    // Zeitbereich-Parameter erstellen
    let timeParams = {};
    if (timeRange === 'custom') {
        const startDate = document.getElementById('startDate').value;
        const endDate = document.getElementById('endDate').value;
        if (startDate && endDate) {
            timeParams = { start_date: startDate, end_date: endDate };
        } else {
            // Wenn benutzerdefiniert, aber keine Daten eingegeben, nichts tun
            hideLoadingIndicator();
            hideDataPreview();
            return;
        }
    } else {
        timeParams = { time_range: timeRange };
    }
    
    // Daten laden
    console.log('🔍 Lade Daten für:', dataType, 'Projekt:', currentProjectId, 'Parameter:', timeParams);
    
    fetch(`/api/projects/${currentProjectId}/data/${dataType}`, {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
            'Cache-Control': 'no-cache',
            'Pragma': 'no-cache'
        },
        body: JSON.stringify(timeParams)
    })
    .then(response => {
        console.log('📡 Response Status:', response.status);
        return response.json();
    })
        .then(result => {
        console.log('📊 API Response:', result);
        
        // API-Response für PV-Kapazität speichern
        window.lastAPIResponse = result;
        
        if (result.success && result.data.length > 0) {
            console.log('✅ Daten erfolgreich geladen:', result.data.length, 'Datensätze');
            console.log('📊 Erste 3 Datenpunkte:', result.data.slice(0, 3));
            currentData = result.data;
            showDataPreview();
            updateDataTypeInfo();
            updateStatistics();
            updateChart();
            updateDataTable();
        } else {
            console.log('❌ Keine Daten gefunden oder API-Fehler');
            console.log('❌ API Response:', result);
            
            // Prüfe ob verfügbarer Zeitraum angegeben ist (für alle Datentypen inkl. Overlay)
            if (result.available_range) {
                showNoDataMessageWithRange(result.available_range, result.message);
            } else if (result.message) {
                // Zeige benutzerdefinierte Fehlermeldung wenn vorhanden
                showNoDataMessageWithText(result.message);
            } else {
                showNoDataMessage();
            }
        }
        hideLoadingIndicator();
    })
    .catch(error => {
        console.error('❌ Fehler beim Laden der Daten:', error);
        showNoDataMessage();
        hideLoadingIndicator();
    });
}

function showDataPreview() {
    document.getElementById('dataPreviewContainer').classList.remove('hidden');
    document.getElementById('noDataMessage').classList.add('hidden');
}

function hideDataPreview() {
    document.getElementById('dataPreviewContainer').classList.add('hidden');
    document.getElementById('noDataMessage').classList.remove('hidden');
}

function showNoDataMessage() {
    document.getElementById('dataPreviewContainer').classList.add('hidden');
    document.getElementById('noDataMessage').classList.remove('hidden');
    document.getElementById('noDataMessage').innerHTML = `
        <i class="fas fa-exclamation-triangle text-yellow-600 text-3xl mb-4"></i>
        <h3 class="text-lg font-semibold text-yellow-800 mb-2">Keine Daten gefunden</h3>
        <p class="text-yellow-700">Für die ausgewählte Kombination wurden keine Daten gefunden.</p>
    `;
}

function showNoDataMessageWithRange(availableRange, message) {
    document.getElementById('dataPreviewContainer').classList.add('hidden');
    document.getElementById('noDataMessage').classList.remove('hidden');
    
    const minDate = new Date(availableRange.min).toLocaleDateString('de-DE');
    const maxDate = new Date(availableRange.max).toLocaleDateString('de-DE');
    
    document.getElementById('noDataMessage').innerHTML = `
        <i class="fas fa-exclamation-triangle text-yellow-600 text-3xl mb-4"></i>
        <h3 class="text-lg font-semibold text-yellow-800 mb-2">Keine Daten für den gewählten Zeitraum gefunden</h3>
        <p class="text-yellow-700 mb-3">${message || 'Für den ausgewählten Zeitraum wurden keine Daten gefunden.'}</p>
        <div class="bg-blue-50 border border-blue-200 rounded-lg p-4 mt-4">
            <h4 class="text-md font-semibold text-blue-800 mb-2">
                <i class="fas fa-info-circle text-blue-600 mr-2"></i>
                Verfügbarer Zeitraum:
            </h4>
            <p class="text-blue-700">
                <strong>Von:</strong> ${minDate}<br>
                <strong>Bis:</strong> ${maxDate}<br>
                <strong>Anzahl Datensätze:</strong> ${availableRange.count.toLocaleString('de-DE')}
            </p>
            <p class="text-sm text-blue-600 mt-2">
                💡 Bitte wählen Sie einen Zeitraum innerhalb des verfügbaren Bereichs.
            </p>
        </div>
    `;
}

function showNoDataMessageWithText(message) {
    document.getElementById('dataPreviewContainer').classList.add('hidden');
    document.getElementById('noDataMessage').classList.remove('hidden');
    document.getElementById('noDataMessage').innerHTML = `
        <i class="fas fa-exclamation-triangle text-yellow-600 text-3xl mb-4"></i>
        <h3 class="text-lg font-semibold text-yellow-800 mb-2">Keine Daten gefunden</h3>
        <p class="text-yellow-700">${message || 'Für die ausgewählte Kombination wurden keine Daten gefunden.'}</p>
    `;
}

function updateDataTypeInfo() {
    const config = dataTypes[currentDataType];
    const infoContainer = document.getElementById('dataTypeInfo');
    
    // Prüfe ob config vorhanden ist (für Overlay und andere spezielle Datentypen)
    if (!config) {
        console.warn(`⚠️ Keine Konfiguration für Datentyp: ${currentDataType}`);
        // Fallback für unbekannte Datentypen
        infoContainer.innerHTML = `
            <div class="flex items-center">
                <i class="fas fa-chart-line text-gray-600 text-2xl mr-3"></i>
                <div>
                    <h4 class="text-lg font-semibold text-gray-800">${currentDataType}</h4>
                    <p class="text-gray-700">${currentData.length} Datensätze</p>
                </div>
            </div>
        `;
        return;
    }
    
    infoContainer.innerHTML = `
        <div class="flex items-center">
            <i class="${config.icon} text-${config.color}-600 text-2xl mr-3"></i>
            <div>
                <h4 class="text-lg font-semibold text-${config.color}-800">${config.name}</h4>
                <p class="text-${config.color}-700">${config.description} • ${currentData.length} Datensätze</p>
            </div>
        </div>
    `;
}

function updateStatistics() {
    if (currentData.length === 0) return;
    
    // Spezielle Behandlung für Overlay-Statistiken
    if (currentDataType === 'overlay') {
        updateOverlayStatistics();
        return;
    }
    
    const config = dataTypes[currentDataType];
    if (!config) {
        console.warn(`⚠️ Keine Konfiguration für Datentyp: ${currentDataType}`);
        return;
    }
    const values = currentData.map(item => parseFloat(item.value)).filter(v => !isNaN(v));
    
    const maxValue = Math.max(...values);
    const minValue = Math.min(...values);
    const avgValue = values.reduce((a, b) => a + b, 0) / values.length;
    
    // Gesamtenergie für Lastprofile berechnen
    let totalEnergy = 0;
    if (currentDataType === 'load_profile') {
        for (let i = 1; i < currentData.length; i++) {
            const timeDiff = (new Date(currentData[i].timestamp) - new Date(currentData[i-1].timestamp)) / (1000 * 60 * 60);
            const avgPower = (currentData[i].value + currentData[i-1].value) / 2;
            totalEnergy += avgPower * timeDiff;
        }
    }
    
    // Gesamtenergie für PVGIS-Solardaten berechnen (Jahresertrag in kWh)
    let totalPVEnergy = 0;
    let annualPVEnergy = 0;
    let pvCapacityKw = 0;
    if (currentDataType === 'solar_radiation') {
        // PV-Kapazität aus API-Response holen (falls verfügbar)
        if (window.lastAPIResponse && window.lastAPIResponse.pv_capacity_kw) {
            pvCapacityKw = window.lastAPIResponse.pv_capacity_kw;
        }
        
        // Summiere alle pv_energy_kwh Werte
        totalPVEnergy = currentData
            .map(item => parseFloat(item.pv_energy_kwh || 0))
            .filter(v => !isNaN(v))
            .reduce((a, b) => a + b, 0);
        
        // Falls pv_energy_kwh nicht vorhanden, berechne aus global_irradiance
        if (totalPVEnergy === 0 && pvCapacityKw > 0) {
            // PV-Energie = global_irradiance (W/m²) * pv_capacity (kWp) * 0.75 / 1000
            // Für stündliche Daten: direkt in kWh
            totalPVEnergy = currentData
                .map(item => {
                    const irradiance = parseFloat(item.value || 0);
                    return (irradiance * pvCapacityKw * 0.75) / 1000.0;
                })
                .filter(v => !isNaN(v))
                .reduce((a, b) => a + b, 0);
        }
        
        // Berechne Jahresertrag (extrapoliert basierend auf Zeitraum)
        if (currentData.length > 0) {
            const firstDate = new Date(currentData[0].timestamp);
            const lastDate = new Date(currentData[currentData.length - 1].timestamp);
            const daysInData = (lastDate - firstDate) / (1000 * 60 * 60 * 24);
            if (daysInData > 0) {
                annualPVEnergy = (totalPVEnergy / daysInData) * 365;
            }
        }
    }
    
    // Gesamtenergie für Wasserkraft-Daten berechnen (Jahresertrag in kWh)
    let totalHydroEnergy = 0;
    let annualHydroEnergy = 0;
    let hydroPowerKw = 0;
    if (currentDataType === 'water_level') {
        // Hydro-Parameter aus API-Response holen (falls verfügbar)
        if (window.lastAPIResponse && window.lastAPIResponse.hydro_power_kw) {
            hydroPowerKw = window.lastAPIResponse.hydro_power_kw;
        }
        
        // Summiere alle hydro_energy_kwh Werte
        totalHydroEnergy = currentData
            .map(item => parseFloat(item.hydro_energy_kwh || 0))
            .filter(v => !isNaN(v))
            .reduce((a, b) => a + b, 0);
        
        // Berechne Jahresertrag (extrapoliert basierend auf Zeitraum)
        if (currentData.length > 0) {
            const firstDate = new Date(currentData[0].timestamp);
            const lastDate = new Date(currentData[currentData.length - 1].timestamp);
            const daysInData = (lastDate - firstDate) / (1000 * 60 * 60 * 24);
            if (daysInData > 0) {
                annualHydroEnergy = (totalHydroEnergy / daysInData) * 365;
            }
        }
    }
    
    // Gesamtenergie für Winddaten berechnen (Jahresertrag in kWh)
    let totalWindEnergy = 0;
    let annualWindEnergy = 0;
    if (currentDataType === 'wind') {
        // Summiere alle energy_kwh Werte
        totalWindEnergy = currentData
            .map(item => parseFloat(item.energy_kwh || 0))
            .filter(v => !isNaN(v))
            .reduce((a, b) => a + b, 0);
        
        // Berechne Jahresertrag (extrapoliert basierend auf Zeitraum)
        if (currentData.length > 0) {
            const firstDate = new Date(currentData[0].timestamp);
            const lastDate = new Date(currentData[currentData.length - 1].timestamp);
            const daysInData = (lastDate - firstDate) / (1000 * 60 * 60 * 24);
            if (daysInData > 0) {
                annualWindEnergy = (totalWindEnergy / daysInData) * 365;
            }
        }
    }
    
    const statsGrid = document.getElementById('statisticsGrid');
    
    // Spezielle Anzeige für PVGIS-Solardaten mit Jahresertrag
    if (currentDataType === 'solar_radiation') {
        statsGrid.innerHTML = `
            <div class="text-center">
                <div class="text-2xl font-bold text-green-600">${maxValue.toFixed(2)} ${config.unit}</div>
                <div class="text-sm text-gray-600">Max. Einstrahlung</div>
            </div>
            <div class="text-center">
                <div class="text-2xl font-bold text-blue-600">${avgValue.toFixed(2)} ${config.unit}</div>
                <div class="text-sm text-gray-600">Ø Einstrahlung</div>
            </div>
            <div class="text-center">
                <div class="text-2xl font-bold text-purple-600">${(totalPVEnergy / 1000).toFixed(2)} MWh</div>
                <div class="text-sm text-gray-600">Gesamtenergie (Zeitraum)</div>
                ${pvCapacityKw > 0 ? `<div class="text-xs text-gray-500 mt-1">PV-Kapazität: ${pvCapacityKw.toFixed(1)} kWp</div>` : ''}
            </div>
            <div class="text-center">
                <div class="text-2xl font-bold text-yellow-600">${(annualPVEnergy / 1000).toFixed(2)} MWh/a</div>
                <div class="text-sm text-gray-600">PV-Jahresertrag (extrapoliert)</div>
                <div class="text-xs text-gray-500 mt-1">${(annualPVEnergy).toFixed(0)} kWh/Jahr</div>
            </div>
        `;
    }
    // Spezielle Anzeige für Wasserkraft-Daten mit Jahresertrag
    else if (currentDataType === 'water_level') {
        statsGrid.innerHTML = `
            <div class="text-center">
                <div class="text-2xl font-bold text-green-600">${maxValue.toFixed(2)} ${config.unit}</div>
                <div class="text-sm text-gray-600">Max. Wasserstand</div>
            </div>
            <div class="text-center">
                <div class="text-2xl font-bold text-blue-600">${avgValue.toFixed(2)} ${config.unit}</div>
                <div class="text-sm text-gray-600">Ø Wasserstand</div>
            </div>
            <div class="text-center">
                <div class="text-2xl font-bold text-purple-600">${(totalHydroEnergy / 1000).toFixed(2)} MWh</div>
                <div class="text-sm text-gray-600">Gesamtenergie (Zeitraum)</div>
                ${hydroPowerKw > 0 ? `<div class="text-xs text-gray-500 mt-1">Hydro-Kapazität: ${hydroPowerKw.toFixed(1)} kW</div>` : ''}
            </div>
            <div class="text-center">
                <div class="text-2xl font-bold text-cyan-600">${(annualHydroEnergy / 1000).toFixed(2)} MWh/a</div>
                <div class="text-sm text-gray-600">Hydro-Jahresertrag (extrapoliert)</div>
                <div class="text-xs text-gray-500 mt-1">${(annualHydroEnergy).toFixed(0)} kWh/Jahr</div>
            </div>
        `;
    }
    // Spezielle Anzeige für Winddaten mit Jahresertrag
    else if (currentDataType === 'wind') {
        statsGrid.innerHTML = `
            <div class="text-center">
                <div class="text-2xl font-bold text-green-600">${maxValue.toFixed(2)} ${config.unit}</div>
                <div class="text-sm text-gray-600">Max. Windleistung</div>
            </div>
            <div class="text-center">
                <div class="text-2xl font-bold text-blue-600">${avgValue.toFixed(2)} ${config.unit}</div>
                <div class="text-sm text-gray-600">Ø Windleistung</div>
            </div>
            <div class="text-center">
                <div class="text-2xl font-bold text-purple-600">${(totalWindEnergy / 1000).toFixed(2)} MWh</div>
                <div class="text-sm text-gray-600">Gesamtenergie (Zeitraum)</div>
            </div>
            <div class="text-center">
                <div class="text-2xl font-bold text-indigo-600">${(annualWindEnergy / 1000).toFixed(2)} MWh/a</div>
                <div class="text-sm text-gray-600">Jahresertrag (extrapoliert)</div>
                <div class="text-xs text-gray-500 mt-1">${(annualWindEnergy).toFixed(0)} kWh/Jahr</div>
            </div>
        `;
    } else {
        statsGrid.innerHTML = `
            <div class="text-center">
                <div class="text-2xl font-bold text-green-600">${maxValue.toFixed(2)} ${config.unit}</div>
                <div class="text-sm text-gray-600">Maximum</div>
            </div>
            <div class="text-center">
                <div class="text-2xl font-bold text-blue-600">${avgValue.toFixed(2)} ${config.unit}</div>
                <div class="text-sm text-gray-600">Durchschnitt</div>
            </div>
            <div class="text-center">
                <div class="text-2xl font-bold text-orange-600">${minValue.toFixed(2)} ${config.unit}</div>
                <div class="text-sm text-gray-600">Minimum</div>
            </div>
            <div class="text-center">
                <div class="text-2xl font-bold text-purple-600">${currentDataType === 'load_profile' ? totalEnergy.toFixed(2) + ' kWh' : currentData.length}</div>
                <div class="text-sm text-gray-600">${currentDataType === 'load_profile' ? 'Gesamtenergie' : 'Datensätze'}</div>
            </div>
        `;
    }
}

function updateOverlayStatistics() {
    const loadValues = currentData.map(item => parseFloat(item.load)).filter(v => !isNaN(v));
    const pvValues = currentData.map(item => parseFloat(item.pv_generation)).filter(v => !isNaN(v));
    const hydroValues = currentData.map(item => parseFloat(item.hydro_generation)).filter(v => !isNaN(v));
    const netLoadValues = currentData.map(item => parseFloat(item.net_load)).filter(v => !isNaN(v));
    
    const loadMax = Math.max(...loadValues);
    const loadMin = Math.min(...loadValues);
    const loadAvg = loadValues.reduce((a, b) => a + b, 0) / loadValues.length;
    
    const pvMax = Math.max(...pvValues);
    const pvMin = Math.min(...pvValues);
    const pvAvg = pvValues.reduce((a, b) => a + b, 0) / pvValues.length;
    
    const hydroMax = Math.max(...hydroValues);
    const hydroMin = Math.min(...hydroValues);
    const hydroAvg = hydroValues.reduce((a, b) => a + b, 0) / hydroValues.length;
    
    const netLoadMax = Math.max(...netLoadValues);
    const netLoadMin = Math.min(...netLoadValues);
    const netLoadAvg = netLoadValues.reduce((a, b) => a + b, 0) / netLoadValues.length;
    
    const statsGrid = document.getElementById('statisticsGrid');
    statsGrid.innerHTML = `
        <div class="text-center">
            <div class="text-lg font-bold text-gray-800">Last</div>
            <div class="text-sm text-green-600">Max: ${loadMax.toFixed(2)} kW</div>
            <div class="text-sm text-blue-600">Ø: ${loadAvg.toFixed(2)} kW</div>
            <div class="text-sm text-orange-600">Min: ${loadMin.toFixed(2)} kW</div>
        </div>
        <div class="text-center">
            <div class="text-lg font-bold text-gray-800">PV-Erzeugung</div>
            <div class="text-sm text-green-600">Max: ${pvMax.toFixed(2)} kW</div>
            <div class="text-sm text-blue-600">Ø: ${pvAvg.toFixed(2)} kW</div>
            <div class="text-sm text-orange-600">Min: ${pvMin.toFixed(2)} kW</div>
        </div>
        <div class="text-center">
            <div class="text-lg font-bold text-gray-800">Wasserkraft</div>
            <div class="text-sm text-green-600">Max: ${hydroMax.toFixed(2)} kW</div>
            <div class="text-sm text-blue-600">Ø: ${hydroAvg.toFixed(2)} kW</div>
            <div class="text-sm text-orange-600">Min: ${hydroMin.toFixed(2)} kW</div>
        </div>
        <div class="text-center">
            <div class="text-lg font-bold text-gray-800">Netto-Last</div>
            <div class="text-sm text-green-600">Max: ${netLoadMax.toFixed(2)} kW</div>
            <div class="text-sm text-blue-600">Ø: ${netLoadAvg.toFixed(2)} kW</div>
            <div class="text-sm text-orange-600">Min: ${netLoadMin.toFixed(2)} kW</div>
        </div>
    `;
}

function updateChart() {
    // Spezielle Behandlung für Overlay-Chart
    if (currentDataType === 'overlay') {
        updateOverlayChart();
        return;
    }
    
    const config = dataTypes[currentDataType];
    if (!config) {
        console.warn(`⚠️ Keine Konfiguration für Datentyp: ${currentDataType}`);
        return;
    }
    const labels = currentData.map(item => new Date(item.timestamp).toLocaleString('de-DE'));
    const values = currentData.map(item => item.value);
    
    if (currentChart) {
        currentChart.destroy();
    }
    
    const ctx = document.getElementById('dataChart').getContext('2d');
    currentChart = new Chart(ctx, {
        type: 'line',
        data: {
            labels: labels,
            datasets: [{
                label: `${config.name} (${config.unit})`,
                data: values,
                borderColor: getColorForDataType(currentDataType),
                backgroundColor: getColorForDataType(currentDataType, 0.1),
                borderWidth: 2,
                fill: true,
                tension: 0.1
            }]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
                x: {
                    title: {
                        display: true,
                        text: 'Zeit'
                    }
                },
                y: {
                    title: {
                        display: true,
                        text: `${config.name} (${config.unit})`
                    }
                }
            },
            plugins: {
                legend: {
                    display: true
                }
            }
        }
    });
}

function getTimeRangeLabelForOverlay() {
    const timeRange = document.getElementById('timeRangeSelect').value;
    const timeRangeLabels = {
        'all': 'Alle Daten',
        'week': 'Letzte Woche',
        'month': 'Letzter Monat',
        'year': 'Letztes Jahr',
        'custom': 'Benutzerdefiniert'
    };
    
    if (timeRange === 'custom') {
        const startDate = document.getElementById('startDate').value;
        const endDate = document.getElementById('endDate').value;
        if (startDate && endDate) {
            const start = new Date(startDate).toLocaleDateString('de-DE');
            const end = new Date(endDate).toLocaleDateString('de-DE');
            return `${start} - ${end}`;
        }
    }
    
    return timeRangeLabels[timeRange] || 'Unbekannt';
}

function updateOverlayChart() {
    if (currentChart) {
        currentChart.destroy();
    }
    
    const ctx = document.getElementById('dataChart').getContext('2d');
    const labels = currentData.map(item => new Date(item.timestamp).toLocaleString('de-DE'));
    
    // Datasets für Overlay-Chart
    const datasets = [];
    
    // Wasserkraft (blauer Bereich)
    if (currentData.some(item => item.hydro_generation > 0)) {
        datasets.push({
            label: 'Wasserkraft Erzeugung',
            data: currentData.map(item => item.hydro_generation),
            backgroundColor: 'rgba(59, 130, 246, 0.6)',
            borderColor: 'rgba(59, 130, 246, 1)',
            borderWidth: 1,
            fill: true,
            order: 1
        });
    }
    
    // PV-Erzeugung (gelber Bereich, gestapelt)
    if (currentData.some(item => item.pv_generation > 0)) {
        datasets.push({
            label: 'PV Erzeugung',
            data: currentData.map(item => item.pv_generation),
            backgroundColor: 'rgba(255, 205, 86, 0.6)',
            borderColor: 'rgba(255, 205, 86, 1)',
            borderWidth: 1,
            fill: true,
            order: 2
        });
    }
    
    // Gesamtlast (graue gestrichelte Linie)
    datasets.push({
        label: 'Hinterstoder Gesamt Last',
        data: currentData.map(item => item.load),
        borderColor: 'rgba(128, 128, 128, 1)',
        backgroundColor: 'transparent',
        borderWidth: 2,
        borderDash: [5, 5],
        fill: false,
        order: 3
    });
    
    // Verkabelungslast (rote Linie)
    datasets.push({
        label: 'Hinterstoder Verkabelung Last',
        data: currentData.map(item => item.net_load),
        borderColor: 'rgba(255, 99, 132, 1)',
        backgroundColor: 'transparent',
        borderWidth: 2,
        fill: false,
        order: 4
    });
    
    currentChart = new Chart(ctx, {
        type: 'line',
        data: {
            labels: labels,
            datasets: datasets
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
                title: {
                    display: true,
                    text: `Last und Erzeugung - ${getTimeRangeLabelForOverlay()}`
                },
                legend: {
                    display: true,
                    position: 'bottom'
                }
            },
            scales: {
                x: {
                    display: true,
                    title: {
                        display: true,
                        text: 'Zeit'
                    }
                },
                y: {
                    display: true,
                    title: {
                        display: true,
                        text: 'Last / kW'
                    },
                    beginAtZero: true
                }
            },
            interaction: {
                intersect: false,
                mode: 'index'
            }
        }
    });
}

function getColorForDataType(dataType, alpha = 1) {
    const colors = {
        'load_profile': `rgba(59, 130, 246, ${alpha})`,
        'solar_radiation': `rgba(245, 158, 11, ${alpha})`,
        'water_level': `rgba(59, 130, 246, ${alpha})`,
        'pvsol_export': `rgba(34, 197, 94, ${alpha})`,
        'weather': `rgba(107, 114, 128, ${alpha})`
    };
    return colors[dataType] || `rgba(59, 130, 246, ${alpha})`;
}

function updateDataTable() {
    const startIndex = (currentPage - 1) * rowsPerPage;
    const endIndex = startIndex + rowsPerPage;
    const pageData = currentData.slice(startIndex, endIndex);
    
    // Spezielle Behandlung für Overlay-Tabelle
    if (currentDataType === 'overlay') {
        updateOverlayTable(pageData);
        return;
    }
    
    const config = dataTypes[currentDataType];
    if (!config) {
        console.warn(`⚠️ Keine Konfiguration für Datentyp: ${currentDataType}`);
        return;
    }
    
    // Tabellen-Header
    const header = document.getElementById('tableHeader');
    header.innerHTML = `
        <th class="px-3 py-2 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
            Zeitstempel
        </th>
        <th class="px-3 py-2 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
            ${config.name} (${config.unit})
        </th>
    `;
    
    // Tabellen-Daten
    const tbody = document.getElementById('dataTable');
    if (pageData.length === 0) {
        tbody.innerHTML = '<tr><td colspan="2" class="px-3 py-2 text-center text-gray-500 text-sm">Keine Daten verfügbar</td></tr>';
    } else {
        tbody.innerHTML = pageData.map(item => `
            <tr>
                <td class="px-3 py-2 text-sm text-gray-900">${new Date(item.timestamp).toLocaleString('de-DE')}</td>
                <td class="px-3 py-2 text-sm text-gray-900">${parseFloat(item.value).toFixed(2)}</td>
            </tr>
        `).join('');
    }
    
    // Paginierung aktualisieren
    updatePagination();
}

function updateOverlayTable(pageData) {
    // Tabellen-Header für Overlay
    const header = document.getElementById('tableHeader');
    header.innerHTML = `
        <th class="px-3 py-2 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
            Zeitstempel
        </th>
        <th class="px-3 py-2 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
            Last (kW)
        </th>
        <th class="px-3 py-2 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
            PV (kW)
        </th>
        <th class="px-3 py-2 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
            Wasserkraft (kW)
        </th>
        <th class="px-3 py-2 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
            Netto-Last (kW)
        </th>
    `;
    
    // Tabellen-Daten
    const tbody = document.getElementById('dataTable');
    if (pageData.length === 0) {
        tbody.innerHTML = '<tr><td colspan="5" class="px-3 py-2 text-center text-gray-500 text-sm">Keine Daten verfügbar</td></tr>';
    } else {
        tbody.innerHTML = pageData.map(item => `
            <tr>
                <td class="px-3 py-2 text-sm text-gray-900">${new Date(item.timestamp).toLocaleString('de-DE')}</td>
                <td class="px-3 py-2 text-sm text-gray-900">${parseFloat(item.load).toFixed(2)}</td>
                <td class="px-3 py-2 text-sm text-gray-900">${parseFloat(item.pv_generation).toFixed(2)}</td>
                <td class="px-3 py-2 text-sm text-gray-900">${parseFloat(item.hydro_generation).toFixed(2)}</td>
                <td class="px-3 py-2 text-sm text-gray-900">${parseFloat(item.net_load).toFixed(2)}</td>
            </tr>
        `).join('');
    }
    
    // Paginierung aktualisieren
    updatePagination();
}

function updatePagination() {
    const totalPages = Math.ceil(currentData.length / rowsPerPage);
    const startIndex = (currentPage - 1) * rowsPerPage + 1;
    const endIndex = Math.min(currentPage * rowsPerPage, currentData.length);
    
    document.getElementById('paginationInfo').textContent = `Zeige ${startIndex}-${endIndex} von ${currentData.length} Einträgen`;
    document.getElementById('pageInfo').textContent = `Seite ${currentPage} von ${totalPages}`;
    
    document.getElementById('prevPage').disabled = currentPage <= 1;
    document.getElementById('nextPage').disabled = currentPage >= totalPages;
}

function changePage(delta) {
    const totalPages = Math.ceil(currentData.length / rowsPerPage);
    const newPage = currentPage + delta;
    
    if (newPage >= 1 && newPage <= totalPages) {
        currentPage = newPage;
        updateDataTable();
    }
}

// setupTimeRangeHandler() wurde entfernt - die Logik ist jetzt in handleTimeRangeChange()

function handleCustomDateChange() {
    const startDate = document.getElementById('startDate').value;
    const endDate = document.getElementById('endDate').value;
    
    // Validiere Datumsbereich
    if (startDate && endDate) {
        const start = new Date(startDate);
        const end = new Date(endDate);
        
        if (start > end) {
            // Zeige Warnung
            showDateWarning('Das Startdatum muss vor dem Enddatum liegen.');
            return;
        }
        
        // Prüfe ob Zeitraum nicht zu groß ist (max. 1 Jahr)
        const daysDiff = (end - start) / (1000 * 60 * 60 * 24);
        if (daysDiff > 365) {
            showDateWarning('Der Zeitraum darf maximal 1 Jahr betragen. Für größere Zeiträume verwenden Sie bitte "Alle Daten".');
            return;
        }
        
        // Verstecke Warnung falls vorhanden
        hideDateWarning();
        
        // Zeige Lade-Animation
        showLoadingIndicator();
        
        // Automatische Aktualisierung nach kurzer Verzögerung (Debouncing)
        clearTimeout(window.dateChangeTimeout);
        window.dateChangeTimeout = setTimeout(() => {
            loadDataPreview();
        }, 1000); // 1 Sekunde Verzögerung
    }
}

function showDateWarning(message) {
    let warningDiv = document.getElementById('dateWarning');
    if (!warningDiv) {
        warningDiv = document.createElement('div');
        warningDiv.id = 'dateWarning';
        warningDiv.className = 'mt-2 p-3 bg-red-50 border border-red-200 rounded-md';
        document.getElementById('customTimeRange').appendChild(warningDiv);
    }
    warningDiv.innerHTML = `
        <div class="flex items-center">
            <i class="fas fa-exclamation-triangle text-red-600 mr-2"></i>
            <span class="text-red-700 text-sm">${message}</span>
        </div>
    `;
}

function hideDateWarning() {
    const warningDiv = document.getElementById('dateWarning');
    if (warningDiv) {
        warningDiv.remove();
    }
}

function showLoadingIndicator() {
    const button = document.querySelector('#customTimeRange button');
    if (button) {
        button.innerHTML = '<i class="fas fa-spinner fa-spin mr-2"></i>Lade...';
        button.disabled = true;
    }
}

function hideLoadingIndicator() {
    const button = document.querySelector('#customTimeRange button');
    if (button) {
        button.innerHTML = '<i class="fas fa-search mr-2"></i>Daten laden';
        button.disabled = false;
    }
}
</script>
{% endblock %} 