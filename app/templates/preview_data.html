{% extends "base.html" %}

{% block title %}Datenvorschau{% endblock %}

{% block content %}
<div class="container mx-auto px-4 py-8">
    <div class="mb-8">
        <h1 class="text-3xl font-bold text-gray-800 mb-4">
            <i class="fas fa-chart-line text-blue-600 mr-3"></i>
            Intelligente Datenvorschau
        </h1>
        <p class="text-gray-600">Betrachte und analysiere alle importierten Daten aus verschiedenen Quellen.</p>
    </div>

    <!-- Projekt- und Datenart-Auswahl -->
    <div class="bg-white rounded-lg shadow-md p-6 mb-6">
        <h2 class="text-xl font-semibold text-gray-800 mb-4">
            <i class="fas fa-filter text-green-600 mr-2"></i>
            Datenauswahl
        </h2>
        <div class="grid grid-cols-1 md:grid-cols-3 gap-4">
            <div>
                <label class="block text-sm font-medium text-gray-700 mb-2">Projekt</label>
                <select id="projectSelect" onchange="loadDataTypes()" class="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500">
                    <option value="">Projekt auswählen...</option>
                </select>
            </div>
            <div class="mb-4">
                <label class="block text-sm font-medium text-gray-700 mb-2">Datenart</label>
                <select id="dataTypeSelect" onchange="handleDataTypeChange()" class="w-full px-3 py-2 border border-gray-300 rounded-md">
                    <option value="">Bitte wählen...</option>
                    <!-- Optionen werden dynamisch über loadDataTypes() geladen -->
                </select>
            </div>
            <div>
                <label class="block text-sm font-medium text-gray-700 mb-2">Zeitraum</label>
                <select id="timeRangeSelect" onchange="handleTimeRangeChange()" class="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500" disabled>
                    <option value="all">Alle Daten</option>
                    <option value="week">Letzte Woche</option>
                    <option value="month">Letzter Monat</option>
                    <option value="year">Letztes Jahr</option>
                    <option value="custom">Benutzerdefiniert</option>
                </select>
            </div>
        </div>
        
        <!-- Benutzerdefinierter Zeitraum (versteckt) -->
        <div id="customTimeRange" class="mt-4 hidden">
            <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                <div>
                    <label class="block text-sm font-medium text-gray-700 mb-2">Von</label>
                    <input type="datetime-local" id="startDate" onchange="handleCustomDateChange()" class="w-full px-3 py-2 border border-gray-300 rounded-md">
                </div>
                <div>
                    <label class="block text-sm font-medium text-gray-700 mb-2">Bis</label>
                    <input type="datetime-local" id="endDate" onchange="handleCustomDateChange()" class="w-full px-3 py-2 border border-gray-300 rounded-md">
                </div>
            </div>
            <div class="mt-4 flex justify-end">
                <button onclick="loadDataPreview()" class="px-4 py-2 bg-blue-600 text-white rounded-md hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-500">
                    <i class="fas fa-search mr-2"></i>Daten laden
                </button>
            </div>
        </div>
    </div>

    <!-- Datenvorschau Container -->
    <div id="dataPreviewContainer" class="hidden">
        <!-- Datenart-spezifische Informationen -->
        <div id="dataTypeInfo" class="bg-blue-50 border border-blue-200 rounded-lg p-4 mb-6">
            <!-- Wird dynamisch gefüllt -->
        </div>

        <!-- Statistiken -->
        <div id="statisticsContainer" class="bg-white rounded-lg shadow-md p-6 mb-6">
            <h3 class="text-lg font-semibold text-gray-800 mb-4">
                <i class="fas fa-chart-bar text-purple-600 mr-2"></i>
                Statistiken
            </h3>
            <div id="statisticsGrid" class="grid grid-cols-2 md:grid-cols-4 gap-4">
                <!-- Wird dynamisch gefüllt -->
            </div>
        </div>

        <!-- Erweiterte Analyse (nur für Lastprofile) -->
        <div id="advancedAnalysisContainer" class="hidden">
            <!-- Basis-KPIs aus lastprofil_analyse -->
            <div id="basicKPIsContainer" class="bg-white rounded-lg shadow-md p-6 mb-6">
                <h3 class="text-lg font-semibold text-gray-800 mb-4">
                    <i class="fas fa-chart-bar text-purple-600 mr-2"></i>
                    Erweiterte Kennzahlen
                </h3>
                <div id="basicKPIsGrid" class="grid grid-cols-2 md:grid-cols-5 gap-4">
                    <!-- Wird dynamisch gefüllt -->
                </div>
            </div>
            
            <!-- Tab-Navigation für verschiedene Analysen -->
            <div class="bg-white rounded-lg shadow-md p-6 mb-6">
                <div class="flex flex-wrap gap-2 mb-4 border-b border-gray-200">
                    <button onclick="showAnalysisTab('ldc')" id="tab-ldc" class="px-4 py-2 bg-blue-600 text-white rounded-t-md hover:bg-blue-700 focus:outline-none">
                        <i class="fas fa-chart-area mr-2"></i>Lastdauerlinie
                    </button>
                    <button onclick="showAnalysisTab('daily')" id="tab-daily" class="px-4 py-2 bg-gray-200 text-gray-700 rounded-t-md hover:bg-gray-300 focus:outline-none">
                        <i class="fas fa-clock mr-2"></i>Tageslastgang
                    </button>
                    <button onclick="showAnalysisTab('weekday')" id="tab-weekday" class="px-4 py-2 bg-gray-200 text-gray-700 rounded-t-md hover:bg-gray-300 focus:outline-none">
                        <i class="fas fa-calendar-week mr-2"></i>Wochentage
                    </button>
                    <button onclick="showAnalysisTab('seasonal')" id="tab-seasonal" class="px-4 py-2 bg-gray-200 text-gray-700 rounded-t-md hover:bg-gray-300 focus:outline-none">
                        <i class="fas fa-calendar-alt mr-2"></i>Saisonal
                    </button>
                </div>
                
                <!-- Tab-Inhalte -->
                <!-- Lastdauerlinie -->
                <div id="content-ldc" class="analysis-tab-content">
                    <h3 class="text-lg font-semibold text-gray-800 mb-4">
                        <i class="fas fa-chart-area text-indigo-600 mr-2"></i>
                        Lastdauerlinie
                    </h3>
                    <div class="h-96">
                        <canvas id="ldcChart"></canvas>
                    </div>
                </div>
                
                <!-- Tageslastgang -->
                <div id="content-daily" class="analysis-tab-content hidden">
                    <h3 class="text-lg font-semibold text-gray-800 mb-4">
                        <i class="fas fa-clock text-blue-600 mr-2"></i>
                        Tageslastgang (24h-Profil)
                    </h3>
                    <div id="dailyProfileInfo" class="mb-4 text-sm text-gray-600">
                        <!-- Wird dynamisch gefüllt -->
                    </div>
                    <div class="h-96">
                        <canvas id="dailyProfileChart"></canvas>
                    </div>
                </div>
                
                <!-- Wochentags-Analyse -->
                <div id="content-weekday" class="analysis-tab-content hidden">
                    <h3 class="text-lg font-semibold text-gray-800 mb-4">
                        <i class="fas fa-calendar-week text-green-600 mr-2"></i>
                        Wochentags-Analyse
                    </h3>
                    <div id="weekdayInfo" class="mb-4 text-sm text-gray-600">
                        <!-- Wird dynamisch gefüllt -->
                    </div>
                    <div id="weekdayWeekSelector" class="mb-4 hidden">
                        <label class="block text-sm font-medium text-gray-700 mb-2">Woche auswählen:</label>
                        <select id="weekSelect" onchange="updateWeekdayChart()" class="px-3 py-2 border border-gray-300 rounded-md">
                            <option value="all">Alle Wochen (Gesamt)</option>
                        </select>
                    </div>
                    <div class="h-96">
                        <canvas id="weekdayChart"></canvas>
                    </div>
                </div>
                
                <!-- Saisonale Analyse -->
                <div id="content-seasonal" class="analysis-tab-content hidden">
                    <h3 class="text-lg font-semibold text-gray-800 mb-4">
                        <i class="fas fa-calendar-alt text-orange-600 mr-2"></i>
                        Saisonale Analyse
                    </h3>
                    <div id="seasonalInfo" class="mb-4 text-sm text-gray-600">
                        <!-- Wird dynamisch gefüllt -->
                    </div>
                    <div class="mb-4">
                        <label class="block text-sm font-medium text-gray-700 mb-2">Ansicht:</label>
                        <select id="seasonalViewSelect" onchange="updateSeasonalChart()" class="px-3 py-2 border border-gray-300 rounded-md">
                            <option value="monthly">Monatlich</option>
                            <option value="quarterly">Quartalsweise</option>
                        </select>
                    </div>
                    <div class="h-96">
                        <canvas id="seasonalChart"></canvas>
                    </div>
                </div>
            </div>
        </div>

        <!-- Visualisierung -->
        <div class="bg-white rounded-lg shadow-md p-6 mb-6">
            <h3 class="text-lg font-semibold text-gray-800 mb-4">
                <i class="fas fa-chart-line text-green-600 mr-2"></i>
                Visualisierung
            </h3>
            <div class="h-96">
                <canvas id="dataChart"></canvas>
            </div>
        </div>

        <!-- Rohdaten -->
        <div class="bg-white rounded-lg shadow-md p-6">
            <div class="flex justify-between items-center mb-4">
                <h3 class="text-lg font-semibold text-gray-800">
                    <i class="fas fa-table text-orange-600 mr-2"></i>
                    Rohdaten
                </h3>
                <div class="flex items-center space-x-2">
                    <span class="text-sm text-gray-600">Zeige:</span>
                    <select id="rowsPerPage" onchange="updateDataTable()" class="text-sm border border-gray-300 rounded px-2 py-1">
                        <option value="10">10</option>
                        <option value="25" selected>25</option>
                        <option value="50">50</option>
                        <option value="100">100</option>
                    </select>
                    <span class="text-sm text-gray-600">Zeilen</span>
                </div>
            </div>
            
            <div class="overflow-x-auto">
                <table class="min-w-full divide-y divide-gray-200 text-sm">
                    <thead class="bg-gray-50">
                        <tr id="tableHeader">
                            <!-- Wird dynamisch gefüllt -->
                        </tr>
                    </thead>
                    <tbody id="dataTable" class="bg-white divide-y divide-gray-200">
                        <!-- Wird dynamisch gefüllt -->
                    </tbody>
                </table>
            </div>
            
            <!-- Paginierung -->
            <div class="flex justify-between items-center mt-4 pt-4 border-t border-gray-200">
                <div class="text-sm text-gray-600">
                    <span id="paginationInfo">Zeige 0 von 0 Einträgen</span>
                </div>
                <div class="flex space-x-2">
                    <button id="prevPage" onclick="changePage(-1)" 
                            class="px-3 py-1 text-sm bg-gray-200 hover:bg-gray-300 rounded disabled:opacity-50 disabled:cursor-not-allowed">
                        ← Vorherige
                    </button>
                    <span id="pageInfo" class="px-3 py-1 text-sm text-gray-600">Seite 1</span>
                    <button id="nextPage" onclick="changePage(1)" 
                            class="px-3 py-1 text-sm bg-gray-200 hover:bg-gray-300 rounded disabled:opacity-50 disabled:cursor-not-allowed">
                        Nächste →
                    </button>
                </div>
            </div>
        </div>
    </div>

    <!-- Keine Daten Nachricht -->
    <div id="noDataMessage" class="bg-yellow-50 border border-yellow-200 rounded-lg p-6 text-center">
        <i class="fas fa-info-circle text-yellow-600 text-3xl mb-4"></i>
        <h3 class="text-lg font-semibold text-yellow-800 mb-2">Keine Daten ausgewählt</h3>
        <p class="text-yellow-700">Wählen Sie ein Projekt und eine Datenart aus, um die Datenvorschau zu sehen.</p>
    </div>
</div>

<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<script>
let currentChart = null;
let currentData = [];
let currentPage = 1;
let rowsPerPage = 25;
let currentProjectId = null;
let currentDataType = null;

// Datenart-Konfiguration
const dataTypes = {
    'load_profile': {
        name: 'Lastprofile',
        icon: 'fas fa-chart-line',
        color: 'blue',
        unit: 'kW',
        description: 'Energieverbrauch und Lastdaten'
    },
    'solar_radiation': {
        name: 'Einstrahlung',
        icon: 'fas fa-sun',
        color: 'yellow',
        unit: 'W/m²',
        description: 'Sonnenstrahlung und Einstrahlungswerte'
    },
    'water_level': {
        name: 'Pegelstände',
        icon: 'fas fa-water',
        color: 'blue',
        unit: 'm',
        description: 'Wasserstände und Pegeldaten'
    },
    'pvsol_export': {
        name: 'PVSol Export',
        icon: 'fas fa-solar-panel',
        color: 'green',
        unit: 'kWh',
        description: 'PVSol Simulationsdaten'
    },
    'weather': {
        name: 'Wetterdaten',
        icon: 'fas fa-cloud',
        color: 'gray',
        unit: '°C',
        description: 'Temperatur, Luftfeuchtigkeit und Wetterdaten'
    },
    'wind': {
        name: 'Winddaten (GeoSphere)',
        icon: 'fas fa-wind',
        color: 'indigo',
        unit: 'kW',
        description: 'Windleistung und Windgeschwindigkeit (GeoSphere)'
    },
    'overlay': {
        name: 'Last & Erzeugung Overlay',
        icon: 'fas fa-layer-group',
        color: 'purple',
        unit: 'kW',
        description: 'Kombinierte Ansicht von Last, PV-Erzeugung und Wasserkraft'
    }
};

document.addEventListener('DOMContentLoaded', function() {
    loadProjects();
    // setupTimeRangeHandler() wird nicht mehr benötigt, da handleTimeRangeChange() direkt verwendet wird
});

function loadProjects() {
    const select = document.getElementById('projectSelect');
    if (!select) {
        console.error('❌ projectSelect Element nicht gefunden!');
        return;
    }
    
    console.log('📡 Lade Projekte von /api/projects...');
    
    fetch('/api/projects')
        .then(response => {
            console.log('📡 Response Status:', response.status);
            if (!response.ok) {
                throw new Error(`HTTP ${response.status}: ${response.statusText}`);
            }
            return response.json();
        })
        .then(projects => {
            console.log('📡 Projekte erhalten:', projects);
            if (!Array.isArray(projects)) {
                console.error('❌ Projekte ist kein Array:', projects);
                return;
            }
            
            select.innerHTML = '<option value="">Projekt auswählen...</option>';
            
            if (projects.length === 0) {
                console.warn('⚠️ Keine Projekte gefunden');
                const option = document.createElement('option');
                option.value = '';
                option.textContent = 'Keine Projekte verfügbar';
                select.appendChild(option);
                return;
            }
            
            projects.forEach(project => {
                if (project && project.id && project.name) {
                    const option = document.createElement('option');
                    option.value = project.id;
                    option.textContent = project.name;
                    select.appendChild(option);
                } else {
                    console.warn('⚠️ Ungültiges Projekt-Objekt:', project);
                }
            });
            
            console.log(`✅ ${projects.length} Projekt(e) geladen`);
        })
        .catch(error => {
            console.error('❌ Fehler beim Laden der Projekte:', error);
            select.innerHTML = '<option value="">Fehler beim Laden</option>';
        });
}

function loadDataTypes() {
    const projectId = document.getElementById('projectSelect').value;
    const dataTypeSelect = document.getElementById('dataTypeSelect');
    const timeRangeSelect = document.getElementById('timeRangeSelect');
    
    if (!projectId) {
        dataTypeSelect.innerHTML = '<option value="">Datenart auswählen...</option>';
        dataTypeSelect.disabled = true;
        timeRangeSelect.disabled = true;
        hideDataPreview();
        return;
    }
    
    currentProjectId = projectId;
    
    // Alle verfügbaren Datenarten anzeigen
    dataTypeSelect.innerHTML = '<option value="">Bitte wählen...</option>';
    
    Object.entries(dataTypes).forEach(([key, config]) => {
        const option = document.createElement('option');
        option.value = key;
        option.textContent = config.name;
        dataTypeSelect.appendChild(option);
    });
    
    // Overlay ist jetzt bereits in dataTypes enthalten, daher keine manuelle Hinzufügung mehr nötig
    
    dataTypeSelect.disabled = false;
    timeRangeSelect.disabled = false;
    
    // Daten NICHT automatisch laden - Benutzer soll zuerst Datenart und Zeitraum wählen
}

function handleDataTypeChange() {
    const dataType = document.getElementById('dataTypeSelect').value;
    const timeRange = document.getElementById('timeRangeSelect').value;
    
    if (!dataType) {
        hideDataPreview();
        return;
    }
    
    // Nur automatisch laden wenn NICHT "Benutzerdefiniert" ausgewählt ist
    // Bei "Benutzerdefiniert" muss der Benutzer zuerst die Datumsfelder prüfen/anpassen
    if (timeRange !== 'custom') {
        loadDataPreview();
    } else {
        // Bei "Benutzerdefiniert": Prüfe ob Datumsfelder gefüllt sind
        const startDate = document.getElementById('startDate').value;
        const endDate = document.getElementById('endDate').value;
        if (startDate && endDate) {
            // Datumsfelder sind gefüllt, lade Daten
            loadDataPreview();
        } else {
            // Datumsfelder sind leer, zeige nur die Auswahl
            hideDataPreview();
        }
    }
}

function handleTimeRangeChange() {
    const timeRange = document.getElementById('timeRangeSelect').value;
    const customTimeRange = document.getElementById('customTimeRange');
    
    if (timeRange === 'custom') {
        customTimeRange.classList.remove('hidden');
        // Setze Standard-Datumsbereich (letzter Monat) nur wenn noch nicht gesetzt
        const startDateInput = document.getElementById('startDate');
        const endDateInput = document.getElementById('endDate');
        
        if (!startDateInput.value || !endDateInput.value) {
            const now = new Date();
            const lastMonth = new Date(now.getFullYear(), now.getMonth() - 1, now.getDate());
            const startDate = lastMonth.toISOString().slice(0, 16);
            const endDate = now.toISOString().slice(0, 16);
            
            startDateInput.value = startDate;
            endDateInput.value = endDate;
        }
        
        // Bei Wechsel zu "Benutzerdefiniert": Lade Daten nur wenn Datenart bereits ausgewählt
        const dataType = document.getElementById('dataTypeSelect').value;
        if (dataType && currentProjectId && startDateInput.value && endDateInput.value) {
            loadDataPreview();
        }
    } else {
        customTimeRange.classList.add('hidden');
        // Bei anderen Zeiträumen: Automatisch laden wenn Datenart bereits ausgewählt
        const dataType = document.getElementById('dataTypeSelect').value;
        if (dataType && currentProjectId) {
            loadDataPreview();
        }
    }
}

function loadDataPreview() {
    const dataType = document.getElementById('dataTypeSelect').value;
    const timeRange = document.getElementById('timeRangeSelect').value;
    
    if (!dataType || !currentProjectId) {
        hideDataPreview();
        hideLoadingIndicator();
        return;
    }
    
    currentDataType = dataType;
    
    // Zeitbereich-Parameter erstellen
    let timeParams = {};
    if (timeRange === 'custom') {
        const startDate = document.getElementById('startDate').value;
        const endDate = document.getElementById('endDate').value;
        if (startDate && endDate) {
            timeParams = { start_date: startDate, end_date: endDate };
        } else {
            // Wenn benutzerdefiniert, aber keine Daten eingegeben, nichts tun
            hideLoadingIndicator();
            hideDataPreview();
            return;
        }
    } else {
        timeParams = { time_range: timeRange };
    }
    
    // Daten laden
    console.log('🔍 Lade Daten für:', dataType, 'Projekt:', currentProjectId, 'Parameter:', timeParams);
    
    fetch(`/api/projects/${currentProjectId}/data/${dataType}`, {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
            'Cache-Control': 'no-cache',
            'Pragma': 'no-cache'
        },
        body: JSON.stringify(timeParams)
    })
    .then(response => {
        console.log('📡 Response Status:', response.status);
        return response.json();
    })
        .then(result => {
        console.log('📊 API Response:', result);
        
        // API-Response für PV-Kapazität speichern
        window.lastAPIResponse = result;
        
        if (result.success && result.data.length > 0) {
            console.log('✅ Daten erfolgreich geladen:', result.data.length, 'Datensätze');
            console.log('📊 Erste 3 Datenpunkte:', result.data.slice(0, 3));
            currentData = result.data;
            showDataPreview();
            updateDataTypeInfo();
            updateStatistics();
            updateChart();
            updateDataTable();
            
            // Erweiterte Analyse für Lastprofile laden
            if (currentDataType === 'load_profile') {
                loadAdvancedAnalysis();
            } else {
                hideAdvancedAnalysis();
            }
        } else {
            console.log('❌ Keine Daten gefunden oder API-Fehler');
            console.log('❌ API Response:', result);
            
            // Prüfe ob verfügbarer Zeitraum angegeben ist (für alle Datentypen inkl. Overlay)
            if (result.available_range) {
                showNoDataMessageWithRange(result.available_range, result.message);
            } else if (result.message) {
                // Zeige benutzerdefinierte Fehlermeldung wenn vorhanden
                showNoDataMessageWithText(result.message);
            } else {
                showNoDataMessage();
            }
        }
        hideLoadingIndicator();
    })
    .catch(error => {
        console.error('❌ Fehler beim Laden der Daten:', error);
        showNoDataMessage();
        hideLoadingIndicator();
    });
}

function showDataPreview() {
    document.getElementById('dataPreviewContainer').classList.remove('hidden');
    document.getElementById('noDataMessage').classList.add('hidden');
}

function hideDataPreview() {
    document.getElementById('dataPreviewContainer').classList.add('hidden');
    document.getElementById('noDataMessage').classList.remove('hidden');
}

function showNoDataMessage() {
    document.getElementById('dataPreviewContainer').classList.add('hidden');
    document.getElementById('noDataMessage').classList.remove('hidden');
    document.getElementById('noDataMessage').innerHTML = `
        <i class="fas fa-exclamation-triangle text-yellow-600 text-3xl mb-4"></i>
        <h3 class="text-lg font-semibold text-yellow-800 mb-2">Keine Daten gefunden</h3>
        <p class="text-yellow-700">Für die ausgewählte Kombination wurden keine Daten gefunden.</p>
    `;
}

function showNoDataMessageWithRange(availableRange, message) {
    document.getElementById('dataPreviewContainer').classList.add('hidden');
    document.getElementById('noDataMessage').classList.remove('hidden');
    
    const minDate = new Date(availableRange.min).toLocaleDateString('de-DE');
    const maxDate = new Date(availableRange.max).toLocaleDateString('de-DE');
    
    document.getElementById('noDataMessage').innerHTML = `
        <i class="fas fa-exclamation-triangle text-yellow-600 text-3xl mb-4"></i>
        <h3 class="text-lg font-semibold text-yellow-800 mb-2">Keine Daten für den gewählten Zeitraum gefunden</h3>
        <p class="text-yellow-700 mb-3">${message || 'Für den ausgewählten Zeitraum wurden keine Daten gefunden.'}</p>
        <div class="bg-blue-50 border border-blue-200 rounded-lg p-4 mt-4">
            <h4 class="text-md font-semibold text-blue-800 mb-2">
                <i class="fas fa-info-circle text-blue-600 mr-2"></i>
                Verfügbarer Zeitraum:
            </h4>
            <p class="text-blue-700">
                <strong>Von:</strong> ${minDate}<br>
                <strong>Bis:</strong> ${maxDate}<br>
                <strong>Anzahl Datensätze:</strong> ${availableRange.count.toLocaleString('de-DE')}
            </p>
            <p class="text-sm text-blue-600 mt-2">
                💡 Bitte wählen Sie einen Zeitraum innerhalb des verfügbaren Bereichs.
            </p>
        </div>
    `;
}

function showNoDataMessageWithText(message) {
    document.getElementById('dataPreviewContainer').classList.add('hidden');
    document.getElementById('noDataMessage').classList.remove('hidden');
    document.getElementById('noDataMessage').innerHTML = `
        <i class="fas fa-exclamation-triangle text-yellow-600 text-3xl mb-4"></i>
        <h3 class="text-lg font-semibold text-yellow-800 mb-2">Keine Daten gefunden</h3>
        <p class="text-yellow-700">${message || 'Für die ausgewählte Kombination wurden keine Daten gefunden.'}</p>
    `;
}

function updateDataTypeInfo() {
    const config = dataTypes[currentDataType];
    const infoContainer = document.getElementById('dataTypeInfo');
    
    // Prüfe ob config vorhanden ist (für Overlay und andere spezielle Datentypen)
    if (!config) {
        console.warn(`⚠️ Keine Konfiguration für Datentyp: ${currentDataType}`);
        // Fallback für unbekannte Datentypen
        infoContainer.innerHTML = `
            <div class="flex items-center">
                <i class="fas fa-chart-line text-gray-600 text-2xl mr-3"></i>
                <div>
                    <h4 class="text-lg font-semibold text-gray-800">${currentDataType}</h4>
                    <p class="text-gray-700">${currentData.length} Datensätze</p>
                </div>
            </div>
        `;
        return;
    }
    
    infoContainer.innerHTML = `
        <div class="flex items-center">
            <i class="${config.icon} text-${config.color}-600 text-2xl mr-3"></i>
            <div>
                <h4 class="text-lg font-semibold text-${config.color}-800">${config.name}</h4>
                <p class="text-${config.color}-700">${config.description} • ${currentData.length} Datensätze</p>
            </div>
        </div>
    `;
}

function updateStatistics() {
    if (currentData.length === 0) return;
    
    // Spezielle Behandlung für Overlay-Statistiken
    if (currentDataType === 'overlay') {
        updateOverlayStatistics();
        return;
    }
    
    const config = dataTypes[currentDataType];
    if (!config) {
        console.warn(`⚠️ Keine Konfiguration für Datentyp: ${currentDataType}`);
        return;
    }
    const values = currentData.map(item => parseFloat(item.value)).filter(v => !isNaN(v));
    
    const maxValue = Math.max(...values);
    const minValue = Math.min(...values);
    const avgValue = values.reduce((a, b) => a + b, 0) / values.length;
    
    // Gesamtenergie für Lastprofile berechnen
    let totalEnergy = 0;
    if (currentDataType === 'load_profile') {
        for (let i = 1; i < currentData.length; i++) {
            const timeDiff = (new Date(currentData[i].timestamp) - new Date(currentData[i-1].timestamp)) / (1000 * 60 * 60);
            const avgPower = (currentData[i].value + currentData[i-1].value) / 2;
            totalEnergy += avgPower * timeDiff;
        }
    }
    
    // Gesamtenergie für PVGIS-Solardaten berechnen (Jahresertrag in kWh)
    let totalPVEnergy = 0;
    let annualPVEnergy = 0;
    let pvCapacityKw = 0;
    if (currentDataType === 'solar_radiation') {
        // PV-Kapazität aus API-Response holen (falls verfügbar)
        if (window.lastAPIResponse && window.lastAPIResponse.pv_capacity_kw) {
            pvCapacityKw = window.lastAPIResponse.pv_capacity_kw;
        }
        
        // Summiere alle pv_energy_kwh Werte
        totalPVEnergy = currentData
            .map(item => parseFloat(item.pv_energy_kwh || 0))
            .filter(v => !isNaN(v))
            .reduce((a, b) => a + b, 0);
        
        // Falls pv_energy_kwh nicht vorhanden, berechne aus global_irradiance
        if (totalPVEnergy === 0 && pvCapacityKw > 0) {
            // PV-Energie = global_irradiance (W/m²) * pv_capacity (kWp) * 0.75 / 1000
            // Für stündliche Daten: direkt in kWh
            totalPVEnergy = currentData
                .map(item => {
                    const irradiance = parseFloat(item.value || 0);
                    return (irradiance * pvCapacityKw * 0.75) / 1000.0;
                })
                .filter(v => !isNaN(v))
                .reduce((a, b) => a + b, 0);
        }
        
        // Berechne Jahresertrag (extrapoliert basierend auf Zeitraum)
        if (currentData.length > 0) {
            const firstDate = new Date(currentData[0].timestamp);
            const lastDate = new Date(currentData[currentData.length - 1].timestamp);
            const daysInData = (lastDate - firstDate) / (1000 * 60 * 60 * 24);
            if (daysInData > 0) {
                annualPVEnergy = (totalPVEnergy / daysInData) * 365;
            }
        }
    }
    
    // Gesamtenergie für Wasserkraft-Daten berechnen (Jahresertrag in kWh)
    let totalHydroEnergy = 0;
    let annualHydroEnergy = 0;
    let hydroPowerKw = 0;
    if (currentDataType === 'water_level') {
        // Hydro-Parameter aus API-Response holen (falls verfügbar)
        if (window.lastAPIResponse && window.lastAPIResponse.hydro_power_kw) {
            hydroPowerKw = window.lastAPIResponse.hydro_power_kw;
        }
        
        // Summiere alle hydro_energy_kwh Werte
        totalHydroEnergy = currentData
            .map(item => parseFloat(item.hydro_energy_kwh || 0))
            .filter(v => !isNaN(v))
            .reduce((a, b) => a + b, 0);
        
        // Berechne Jahresertrag (extrapoliert basierend auf Zeitraum)
        if (currentData.length > 0) {
            const firstDate = new Date(currentData[0].timestamp);
            const lastDate = new Date(currentData[currentData.length - 1].timestamp);
            const daysInData = (lastDate - firstDate) / (1000 * 60 * 60 * 24);
            if (daysInData > 0) {
                annualHydroEnergy = (totalHydroEnergy / daysInData) * 365;
            }
        }
    }
    
    // Gesamtenergie für Winddaten berechnen (Jahresertrag in kWh)
    let totalWindEnergy = 0;
    let annualWindEnergy = 0;
    if (currentDataType === 'wind') {
        // Summiere alle energy_kwh Werte
        totalWindEnergy = currentData
            .map(item => parseFloat(item.energy_kwh || 0))
            .filter(v => !isNaN(v))
            .reduce((a, b) => a + b, 0);
        
        // Berechne Jahresertrag (extrapoliert basierend auf Zeitraum)
        if (currentData.length > 0) {
            const firstDate = new Date(currentData[0].timestamp);
            const lastDate = new Date(currentData[currentData.length - 1].timestamp);
            const daysInData = (lastDate - firstDate) / (1000 * 60 * 60 * 24);
            if (daysInData > 0) {
                annualWindEnergy = (totalWindEnergy / daysInData) * 365;
            }
        }
    }
    
    const statsGrid = document.getElementById('statisticsGrid');
    
    // Spezielle Anzeige für PVGIS-Solardaten mit Jahresertrag
    if (currentDataType === 'solar_radiation') {
        statsGrid.innerHTML = `
            <div class="text-center">
                <div class="text-2xl font-bold text-green-600">${maxValue.toFixed(2)} ${config.unit}</div>
                <div class="text-sm text-gray-600">Max. Einstrahlung</div>
            </div>
            <div class="text-center">
                <div class="text-2xl font-bold text-blue-600">${avgValue.toFixed(2)} ${config.unit}</div>
                <div class="text-sm text-gray-600">Ø Einstrahlung</div>
            </div>
            <div class="text-center">
                <div class="text-2xl font-bold text-purple-600">${(totalPVEnergy / 1000).toFixed(2)} MWh</div>
                <div class="text-sm text-gray-600">Gesamtenergie (Zeitraum)</div>
                ${pvCapacityKw > 0 ? `<div class="text-xs text-gray-500 mt-1">PV-Kapazität: ${pvCapacityKw.toFixed(1)} kWp</div>` : ''}
            </div>
            <div class="text-center">
                <div class="text-2xl font-bold text-yellow-600">${(annualPVEnergy / 1000).toFixed(2)} MWh/a</div>
                <div class="text-sm text-gray-600">PV-Jahresertrag (extrapoliert)</div>
                <div class="text-xs text-gray-500 mt-1">${(annualPVEnergy).toFixed(0)} kWh/Jahr</div>
            </div>
        `;
    }
    // Spezielle Anzeige für Wasserkraft-Daten mit Jahresertrag
    else if (currentDataType === 'water_level') {
        statsGrid.innerHTML = `
            <div class="text-center">
                <div class="text-2xl font-bold text-green-600">${maxValue.toFixed(2)} ${config.unit}</div>
                <div class="text-sm text-gray-600">Max. Wasserstand</div>
            </div>
            <div class="text-center">
                <div class="text-2xl font-bold text-blue-600">${avgValue.toFixed(2)} ${config.unit}</div>
                <div class="text-sm text-gray-600">Ø Wasserstand</div>
            </div>
            <div class="text-center">
                <div class="text-2xl font-bold text-purple-600">${(totalHydroEnergy / 1000).toFixed(2)} MWh</div>
                <div class="text-sm text-gray-600">Gesamtenergie (Zeitraum)</div>
                ${hydroPowerKw > 0 ? `<div class="text-xs text-gray-500 mt-1">Hydro-Kapazität: ${hydroPowerKw.toFixed(1)} kW</div>` : ''}
            </div>
            <div class="text-center">
                <div class="text-2xl font-bold text-cyan-600">${(annualHydroEnergy / 1000).toFixed(2)} MWh/a</div>
                <div class="text-sm text-gray-600">Hydro-Jahresertrag (extrapoliert)</div>
                <div class="text-xs text-gray-500 mt-1">${(annualHydroEnergy).toFixed(0)} kWh/Jahr</div>
            </div>
        `;
    }
    // Spezielle Anzeige für Winddaten mit Jahresertrag
    else if (currentDataType === 'wind') {
        statsGrid.innerHTML = `
            <div class="text-center">
                <div class="text-2xl font-bold text-green-600">${maxValue.toFixed(2)} ${config.unit}</div>
                <div class="text-sm text-gray-600">Max. Windleistung</div>
            </div>
            <div class="text-center">
                <div class="text-2xl font-bold text-blue-600">${avgValue.toFixed(2)} ${config.unit}</div>
                <div class="text-sm text-gray-600">Ø Windleistung</div>
            </div>
            <div class="text-center">
                <div class="text-2xl font-bold text-purple-600">${(totalWindEnergy / 1000).toFixed(2)} MWh</div>
                <div class="text-sm text-gray-600">Gesamtenergie (Zeitraum)</div>
            </div>
            <div class="text-center">
                <div class="text-2xl font-bold text-indigo-600">${(annualWindEnergy / 1000).toFixed(2)} MWh/a</div>
                <div class="text-sm text-gray-600">Jahresertrag (extrapoliert)</div>
                <div class="text-xs text-gray-500 mt-1">${(annualWindEnergy).toFixed(0)} kWh/Jahr</div>
            </div>
        `;
    } else {
        statsGrid.innerHTML = `
            <div class="text-center">
                <div class="text-2xl font-bold text-green-600">${maxValue.toFixed(2)} ${config.unit}</div>
                <div class="text-sm text-gray-600">Maximum</div>
            </div>
            <div class="text-center">
                <div class="text-2xl font-bold text-blue-600">${avgValue.toFixed(2)} ${config.unit}</div>
                <div class="text-sm text-gray-600">Durchschnitt</div>
            </div>
            <div class="text-center">
                <div class="text-2xl font-bold text-orange-600">${minValue.toFixed(2)} ${config.unit}</div>
                <div class="text-sm text-gray-600">Minimum</div>
            </div>
            <div class="text-center">
                <div class="text-2xl font-bold text-purple-600">${currentDataType === 'load_profile' ? totalEnergy.toFixed(2) + ' kWh' : currentData.length}</div>
                <div class="text-sm text-gray-600">${currentDataType === 'load_profile' ? 'Gesamtenergie' : 'Datensätze'}</div>
            </div>
        `;
    }
}

function updateOverlayStatistics() {
    const loadValues = currentData.map(item => parseFloat(item.load)).filter(v => !isNaN(v));
    const pvValues = currentData.map(item => parseFloat(item.pv_generation)).filter(v => !isNaN(v));
    const hydroValues = currentData.map(item => parseFloat(item.hydro_generation)).filter(v => !isNaN(v));
    const netLoadValues = currentData.map(item => parseFloat(item.net_load)).filter(v => !isNaN(v));
    
    const loadMax = Math.max(...loadValues);
    const loadMin = Math.min(...loadValues);
    const loadAvg = loadValues.reduce((a, b) => a + b, 0) / loadValues.length;
    
    const pvMax = Math.max(...pvValues);
    const pvMin = Math.min(...pvValues);
    const pvAvg = pvValues.reduce((a, b) => a + b, 0) / pvValues.length;
    
    const hydroMax = Math.max(...hydroValues);
    const hydroMin = Math.min(...hydroValues);
    const hydroAvg = hydroValues.reduce((a, b) => a + b, 0) / hydroValues.length;
    
    const netLoadMax = Math.max(...netLoadValues);
    const netLoadMin = Math.min(...netLoadValues);
    const netLoadAvg = netLoadValues.reduce((a, b) => a + b, 0) / netLoadValues.length;
    
    const statsGrid = document.getElementById('statisticsGrid');
    statsGrid.innerHTML = `
        <div class="text-center">
            <div class="text-lg font-bold text-gray-800">Last</div>
            <div class="text-sm text-green-600">Max: ${loadMax.toFixed(2)} kW</div>
            <div class="text-sm text-blue-600">Ø: ${loadAvg.toFixed(2)} kW</div>
            <div class="text-sm text-orange-600">Min: ${loadMin.toFixed(2)} kW</div>
        </div>
        <div class="text-center">
            <div class="text-lg font-bold text-gray-800">PV-Erzeugung</div>
            <div class="text-sm text-green-600">Max: ${pvMax.toFixed(2)} kW</div>
            <div class="text-sm text-blue-600">Ø: ${pvAvg.toFixed(2)} kW</div>
            <div class="text-sm text-orange-600">Min: ${pvMin.toFixed(2)} kW</div>
        </div>
        <div class="text-center">
            <div class="text-lg font-bold text-gray-800">Wasserkraft</div>
            <div class="text-sm text-green-600">Max: ${hydroMax.toFixed(2)} kW</div>
            <div class="text-sm text-blue-600">Ø: ${hydroAvg.toFixed(2)} kW</div>
            <div class="text-sm text-orange-600">Min: ${hydroMin.toFixed(2)} kW</div>
        </div>
        <div class="text-center">
            <div class="text-lg font-bold text-gray-800">Netto-Last</div>
            <div class="text-sm text-green-600">Max: ${netLoadMax.toFixed(2)} kW</div>
            <div class="text-sm text-blue-600">Ø: ${netLoadAvg.toFixed(2)} kW</div>
            <div class="text-sm text-orange-600">Min: ${netLoadMin.toFixed(2)} kW</div>
        </div>
    `;
}

function updateChart() {
    // Spezielle Behandlung für Overlay-Chart
    if (currentDataType === 'overlay') {
        updateOverlayChart();
        return;
    }
    
    const config = dataTypes[currentDataType];
    if (!config) {
        console.warn(`⚠️ Keine Konfiguration für Datentyp: ${currentDataType}`);
        return;
    }
    const labels = currentData.map(item => new Date(item.timestamp).toLocaleString('de-DE'));
    const values = currentData.map(item => item.value);
    
    if (currentChart) {
        currentChart.destroy();
    }
    
    const ctx = document.getElementById('dataChart').getContext('2d');
    currentChart = new Chart(ctx, {
        type: 'line',
        data: {
            labels: labels,
            datasets: [{
                label: `${config.name} (${config.unit})`,
                data: values,
                borderColor: getColorForDataType(currentDataType),
                backgroundColor: getColorForDataType(currentDataType, 0.1),
                borderWidth: 2,
                fill: true,
                tension: 0.1
            }]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
                x: {
                    title: {
                        display: true,
                        text: 'Zeit'
                    }
                },
                y: {
                    title: {
                        display: true,
                        text: `${config.name} (${config.unit})`
                    }
                }
            },
            plugins: {
                legend: {
                    display: true
                }
            }
        }
    });
}

function getTimeRangeLabelForOverlay() {
    const timeRange = document.getElementById('timeRangeSelect').value;
    const timeRangeLabels = {
        'all': 'Alle Daten',
        'week': 'Letzte Woche',
        'month': 'Letzter Monat',
        'year': 'Letztes Jahr',
        'custom': 'Benutzerdefiniert'
    };
    
    if (timeRange === 'custom') {
        const startDate = document.getElementById('startDate').value;
        const endDate = document.getElementById('endDate').value;
        if (startDate && endDate) {
            const start = new Date(startDate).toLocaleDateString('de-DE');
            const end = new Date(endDate).toLocaleDateString('de-DE');
            return `${start} - ${end}`;
        }
    }
    
    return timeRangeLabels[timeRange] || 'Unbekannt';
}

function updateOverlayChart() {
    if (currentChart) {
        currentChart.destroy();
    }
    
    const ctx = document.getElementById('dataChart').getContext('2d');
    const labels = currentData.map(item => new Date(item.timestamp).toLocaleString('de-DE'));
    
    // Datasets für Overlay-Chart
    const datasets = [];
    
    // Wasserkraft (blauer Bereich)
    if (currentData.some(item => item.hydro_generation > 0)) {
        datasets.push({
            label: 'Wasserkraft Erzeugung',
            data: currentData.map(item => item.hydro_generation),
            backgroundColor: 'rgba(59, 130, 246, 0.6)',
            borderColor: 'rgba(59, 130, 246, 1)',
            borderWidth: 1,
            fill: true,
            order: 1
        });
    }
    
    // PV-Erzeugung (gelber Bereich, gestapelt)
    if (currentData.some(item => item.pv_generation > 0)) {
        datasets.push({
            label: 'PV Erzeugung',
            data: currentData.map(item => item.pv_generation),
            backgroundColor: 'rgba(255, 205, 86, 0.6)',
            borderColor: 'rgba(255, 205, 86, 1)',
            borderWidth: 1,
            fill: true,
            order: 2
        });
    }
    
    // Gesamtlast (graue gestrichelte Linie)
    datasets.push({
        label: 'Hinterstoder Gesamt Last',
        data: currentData.map(item => item.load),
        borderColor: 'rgba(128, 128, 128, 1)',
        backgroundColor: 'transparent',
        borderWidth: 2,
        borderDash: [5, 5],
        fill: false,
        order: 3
    });
    
    // Verkabelungslast (rote Linie)
    datasets.push({
        label: 'Hinterstoder Verkabelung Last',
        data: currentData.map(item => item.net_load),
        borderColor: 'rgba(255, 99, 132, 1)',
        backgroundColor: 'transparent',
        borderWidth: 2,
        fill: false,
        order: 4
    });
    
    currentChart = new Chart(ctx, {
        type: 'line',
        data: {
            labels: labels,
            datasets: datasets
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
                title: {
                    display: true,
                    text: `Last und Erzeugung - ${getTimeRangeLabelForOverlay()}`
                },
                legend: {
                    display: true,
                    position: 'bottom'
                }
            },
            scales: {
                x: {
                    display: true,
                    title: {
                        display: true,
                        text: 'Zeit'
                    }
                },
                y: {
                    display: true,
                    title: {
                        display: true,
                        text: 'Last / kW'
                    },
                    beginAtZero: true
                }
            },
            interaction: {
                intersect: false,
                mode: 'index'
            }
        }
    });
}

function getColorForDataType(dataType, alpha = 1) {
    const colors = {
        'load_profile': `rgba(59, 130, 246, ${alpha})`,
        'solar_radiation': `rgba(245, 158, 11, ${alpha})`,
        'water_level': `rgba(59, 130, 246, ${alpha})`,
        'pvsol_export': `rgba(34, 197, 94, ${alpha})`,
        'weather': `rgba(107, 114, 128, ${alpha})`
    };
    return colors[dataType] || `rgba(59, 130, 246, ${alpha})`;
}

function updateDataTable() {
    const startIndex = (currentPage - 1) * rowsPerPage;
    const endIndex = startIndex + rowsPerPage;
    const pageData = currentData.slice(startIndex, endIndex);
    
    // Spezielle Behandlung für Overlay-Tabelle
    if (currentDataType === 'overlay') {
        updateOverlayTable(pageData);
        return;
    }
    
    const config = dataTypes[currentDataType];
    if (!config) {
        console.warn(`⚠️ Keine Konfiguration für Datentyp: ${currentDataType}`);
        return;
    }
    
    // Tabellen-Header
    const header = document.getElementById('tableHeader');
    header.innerHTML = `
        <th class="px-3 py-2 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
            Zeitstempel
        </th>
        <th class="px-3 py-2 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
            ${config.name} (${config.unit})
        </th>
    `;
    
    // Tabellen-Daten
    const tbody = document.getElementById('dataTable');
    if (pageData.length === 0) {
        tbody.innerHTML = '<tr><td colspan="2" class="px-3 py-2 text-center text-gray-500 text-sm">Keine Daten verfügbar</td></tr>';
    } else {
        tbody.innerHTML = pageData.map(item => `
            <tr>
                <td class="px-3 py-2 text-sm text-gray-900">${new Date(item.timestamp).toLocaleString('de-DE')}</td>
                <td class="px-3 py-2 text-sm text-gray-900">${parseFloat(item.value).toFixed(2)}</td>
            </tr>
        `).join('');
    }
    
    // Paginierung aktualisieren
    updatePagination();
}

function updateOverlayTable(pageData) {
    // Tabellen-Header für Overlay
    const header = document.getElementById('tableHeader');
    header.innerHTML = `
        <th class="px-3 py-2 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
            Zeitstempel
        </th>
        <th class="px-3 py-2 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
            Last (kW)
        </th>
        <th class="px-3 py-2 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
            PV (kW)
        </th>
        <th class="px-3 py-2 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
            Wasserkraft (kW)
        </th>
        <th class="px-3 py-2 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
            Netto-Last (kW)
        </th>
    `;
    
    // Tabellen-Daten
    const tbody = document.getElementById('dataTable');
    if (pageData.length === 0) {
        tbody.innerHTML = '<tr><td colspan="5" class="px-3 py-2 text-center text-gray-500 text-sm">Keine Daten verfügbar</td></tr>';
    } else {
        tbody.innerHTML = pageData.map(item => `
            <tr>
                <td class="px-3 py-2 text-sm text-gray-900">${new Date(item.timestamp).toLocaleString('de-DE')}</td>
                <td class="px-3 py-2 text-sm text-gray-900">${parseFloat(item.load).toFixed(2)}</td>
                <td class="px-3 py-2 text-sm text-gray-900">${parseFloat(item.pv_generation).toFixed(2)}</td>
                <td class="px-3 py-2 text-sm text-gray-900">${parseFloat(item.hydro_generation).toFixed(2)}</td>
                <td class="px-3 py-2 text-sm text-gray-900">${parseFloat(item.net_load).toFixed(2)}</td>
            </tr>
        `).join('');
    }
    
    // Paginierung aktualisieren
    updatePagination();
}

function updatePagination() {
    const totalPages = Math.ceil(currentData.length / rowsPerPage);
    const startIndex = (currentPage - 1) * rowsPerPage + 1;
    const endIndex = Math.min(currentPage * rowsPerPage, currentData.length);
    
    document.getElementById('paginationInfo').textContent = `Zeige ${startIndex}-${endIndex} von ${currentData.length} Einträgen`;
    document.getElementById('pageInfo').textContent = `Seite ${currentPage} von ${totalPages}`;
    
    document.getElementById('prevPage').disabled = currentPage <= 1;
    document.getElementById('nextPage').disabled = currentPage >= totalPages;
}

function changePage(delta) {
    const totalPages = Math.ceil(currentData.length / rowsPerPage);
    const newPage = currentPage + delta;
    
    if (newPage >= 1 && newPage <= totalPages) {
        currentPage = newPage;
        updateDataTable();
    }
}

// setupTimeRangeHandler() wurde entfernt - die Logik ist jetzt in handleTimeRangeChange()

function handleCustomDateChange() {
    const startDate = document.getElementById('startDate').value;
    const endDate = document.getElementById('endDate').value;
    
    // Validiere Datumsbereich
    if (startDate && endDate) {
        const start = new Date(startDate);
        const end = new Date(endDate);
        
        if (start > end) {
            // Zeige Warnung
            showDateWarning('Das Startdatum muss vor dem Enddatum liegen.');
            return;
        }
        
        // Prüfe ob Zeitraum nicht zu groß ist (max. 1 Jahr)
        const daysDiff = (end - start) / (1000 * 60 * 60 * 24);
        if (daysDiff > 365) {
            showDateWarning('Der Zeitraum darf maximal 1 Jahr betragen. Für größere Zeiträume verwenden Sie bitte "Alle Daten".');
            return;
        }
        
        // Verstecke Warnung falls vorhanden
        hideDateWarning();
        
        // Zeige Lade-Animation
        showLoadingIndicator();
        
        // Automatische Aktualisierung nach kurzer Verzögerung (Debouncing)
        clearTimeout(window.dateChangeTimeout);
        window.dateChangeTimeout = setTimeout(() => {
            loadDataPreview();
        }, 1000); // 1 Sekunde Verzögerung
    }
}

function showDateWarning(message) {
    let warningDiv = document.getElementById('dateWarning');
    if (!warningDiv) {
        warningDiv = document.createElement('div');
        warningDiv.id = 'dateWarning';
        warningDiv.className = 'mt-2 p-3 bg-red-50 border border-red-200 rounded-md';
        document.getElementById('customTimeRange').appendChild(warningDiv);
    }
    warningDiv.innerHTML = `
        <div class="flex items-center">
            <i class="fas fa-exclamation-triangle text-red-600 mr-2"></i>
            <span class="text-red-700 text-sm">${message}</span>
        </div>
    `;
}

function hideDateWarning() {
    const warningDiv = document.getElementById('dateWarning');
    if (warningDiv) {
        warningDiv.remove();
    }
}

function showLoadingIndicator() {
    const button = document.querySelector('#customTimeRange button');
    if (button) {
        button.innerHTML = '<i class="fas fa-spinner fa-spin mr-2"></i>Lade...';
        button.disabled = true;
    }
}

function hideLoadingIndicator() {
    const button = document.querySelector('#customTimeRange button');
    if (button) {
        button.innerHTML = '<i class="fas fa-search mr-2"></i>Daten laden';
        button.disabled = false;
    }
}

// Erweiterte Analyse für Lastprofile
let ldcChart = null;
let dailyProfileChart = null;
let weekdayChart = null;
let seasonalChart = null;
let currentAnalysisData = null;

async function loadAdvancedAnalysis() {
    if (!currentProjectId || currentDataType !== 'load_profile') {
        hideAdvancedAnalysis();
        return;
    }
    
    const timeParams = {};
    const timeRange = document.getElementById('timeRangeSelect').value;
    
    if (timeRange === 'custom') {
        const startDate = document.getElementById('startDate').value;
        const endDate = document.getElementById('endDate').value;
        if (startDate && endDate) {
            timeParams.start_date = startDate;
            timeParams.end_date = endDate;
        }
    } else {
        timeParams.time_range = timeRange;
    }
    
    try {
        const response = await fetch(`/api/projects/${currentProjectId}/data/load_profile/analysis`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                ...timeParams,
                analysis_types: ['all']
            })
        });
        
        const result = await response.json();
        
        if (result.success && result.data) {
            displayAdvancedAnalysis(result.data);
        } else {
            console.warn('⚠️ Erweiterte Analyse nicht verfügbar:', result.error || 'Unbekannter Fehler');
            hideAdvancedAnalysis();
        }
    } catch (error) {
        console.error('❌ Fehler beim Laden der erweiterten Analyse:', error);
        hideAdvancedAnalysis();
    }
}

function displayAdvancedAnalysis(data) {
    // Erweiterte Analyse-Sektion anzeigen
    document.getElementById('advancedAnalysisContainer').classList.remove('hidden');
    
    // Daten speichern für Tab-Wechsel
    currentAnalysisData = data;
    
    // Basis-KPIs anzeigen
    if (data.basic_kpis) {
        const kpis = data.basic_kpis;
        const kpisGrid = document.getElementById('basicKPIsGrid');
        kpisGrid.innerHTML = `
            <div class="text-center">
                <div class="text-2xl font-bold text-green-600">${(kpis.E_jahr_kWh / 1000).toFixed(2)} MWh</div>
                <div class="text-sm text-gray-600">Jahresenergie</div>
                <div class="text-xs text-gray-500 mt-1">${kpis.E_jahr_kWh.toFixed(0)} kWh</div>
            </div>
            <div class="text-center">
                <div class="text-2xl font-bold text-red-600">${kpis.P_max_kW.toFixed(2)} kW</div>
                <div class="text-sm text-gray-600">Max. Leistung</div>
            </div>
            <div class="text-center">
                <div class="text-2xl font-bold text-blue-600">${kpis.P_mean_kW.toFixed(2)} kW</div>
                <div class="text-sm text-gray-600">Ø Leistung</div>
            </div>
            <div class="text-center">
                <div class="text-2xl font-bold text-purple-600">${(kpis.Lastfaktor * 100).toFixed(1)}%</div>
                <div class="text-sm text-gray-600">Lastfaktor</div>
            </div>
            <div class="text-center">
                <div class="text-2xl font-bold text-orange-600">${kpis.Benutzungsdauer_h.toFixed(0)} h</div>
                <div class="text-sm text-gray-600">Vollbenutzungsstunden</div>
            </div>
        `;
    }
    
    // Standard-Tab: Lastdauerlinie
    showAnalysisTab('ldc');
    
    // Alle verfügbaren Analysen rendern
    if (data.load_duration_curve && data.load_duration_curve.length > 0) {
        renderLoadDurationCurve(data.load_duration_curve);
    }
    
    if (data.analyses && data.analyses.daily_profile) {
        renderDailyProfileChart(data.analyses.daily_profile);
    }
    
    if (data.analyses && data.analyses.weekday_analysis) {
        renderWeekdayChart(data.analyses.weekday_analysis);
    }
    
    if (data.analyses && data.analyses.seasonal_analysis) {
        renderSeasonalChart(data.analyses.seasonal_analysis);
    }
}

function showAnalysisTab(tabName) {
    // Alle Tabs verstecken
    document.querySelectorAll('.analysis-tab-content').forEach(content => {
        content.classList.add('hidden');
    });
    
    // Alle Tab-Buttons zurücksetzen
    document.querySelectorAll('[id^="tab-"]').forEach(btn => {
        btn.classList.remove('bg-blue-600', 'text-white');
        btn.classList.add('bg-gray-200', 'text-gray-700');
    });
    
    // Gewählten Tab anzeigen
    document.getElementById(`content-${tabName}`).classList.remove('hidden');
    const tabBtn = document.getElementById(`tab-${tabName}`);
    if (tabBtn) {
        tabBtn.classList.remove('bg-gray-200', 'text-gray-700');
        tabBtn.classList.add('bg-blue-600', 'text-white');
    }
}

function hideAdvancedAnalysis() {
    document.getElementById('advancedAnalysisContainer').classList.add('hidden');
    if (ldcChart) {
        ldcChart.destroy();
        ldcChart = null;
    }
    if (dailyProfileChart) {
        dailyProfileChart.destroy();
        dailyProfileChart = null;
    }
    if (weekdayChart) {
        weekdayChart.destroy();
        weekdayChart = null;
    }
    if (seasonalChart) {
        seasonalChart.destroy();
        seasonalChart = null;
    }
    currentAnalysisData = null;
}

function renderLoadDurationCurve(ldc) {
    const ctx = document.getElementById('ldcChart');
    if (!ctx) return;
    
    // Alten Chart zerstören falls vorhanden
    if (ldcChart) {
        ldcChart.destroy();
    }
    
    const hours = ldc.map(p => p.hours);
    const power = ldc.map(p => p.P_kW);
    
    ldcChart = new Chart(ctx.getContext('2d'), {
        type: 'line',
        data: {
            labels: hours.map(h => h.toFixed(1)),
            datasets: [{
                label: 'Lastdauerlinie (kW)',
                data: power,
                borderColor: 'rgba(168, 85, 247, 1)',
                backgroundColor: 'rgba(168, 85, 247, 0.1)',
                borderWidth: 2,
                fill: true,
                tension: 0.1
            }]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
                x: {
                    title: {
                        display: true,
                        text: 'Stunden (kumuliert)'
                    }
                },
                y: {
                    title: {
                        display: true,
                        text: 'Leistung (kW)'
                    },
                    beginAtZero: true
                }
            },
            plugins: {
                legend: {
                    display: true,
                    position: 'top'
                },
                tooltip: {
                    callbacks: {
                        label: function(context) {
                            return `Leistung: ${context.parsed.y.toFixed(2)} kW`;
                        }
                    }
                }
            }
        }
    });
}

function renderDailyProfileChart(data) {
    const ctx = document.getElementById('dailyProfileChart');
    if (!ctx) return;
    
    // Alten Chart zerstören falls vorhanden
    if (dailyProfileChart) {
        dailyProfileChart.destroy();
    }
    
    const hours = data.hours.map(h => h.hour);
    const power = data.hours.map(h => h.P_avg_kW);
    
    // Info-Box aktualisieren
    const infoDiv = document.getElementById('dailyProfileInfo');
    if (infoDiv) {
        const peakHoursStr = data.peak_hours.map(h => `${h}:00`).join(', ');
        const lowHoursStr = data.low_hours.map(h => `${h}:00`).join(', ');
        const dayTypeInfo = data.day_type ? `<div class="col-span-2 md:col-span-4 mb-2 p-2 bg-blue-50 border border-blue-200 rounded">
            <span class="font-semibold text-blue-800">📅 Dargestellter Zeitraum:</span> 
            <span class="text-blue-700">${data.day_type || 'Alle Tage'}</span>
            ${data.num_days ? `<span class="text-blue-600 ml-2">(${data.num_days} ${data.num_days === 1 ? 'Tag' : 'Tage'})</span>` : ''}
            ${data.date_range ? `<span class="text-blue-600 ml-2">• ${data.date_range}</span>` : ''}
        </div>` : '';
        
        infoDiv.innerHTML = `
            ${dayTypeInfo}
            <div class="grid grid-cols-2 md:grid-cols-4 gap-4">
                <div>
                    <span class="font-semibold">Peak-Zeit:</span> ${data.max_hour}:00 Uhr (${data.max_value_kW.toFixed(2)} kW)
                </div>
                <div>
                    <span class="font-semibold">Tiefzeit:</span> ${data.min_hour}:00 Uhr (${data.min_value_kW.toFixed(2)} kW)
                </div>
                <div>
                    <span class="font-semibold">Peak-Stunden:</span> ${peakHoursStr || 'Keine'}
                </div>
                <div>
                    <span class="font-semibold">Tief-Stunden:</span> ${lowHoursStr || 'Keine'}
                </div>
            </div>
        `;
    }
    
    // Gesamtdurchschnitt für Trendlinie
    const overallAvg = data.overall_avg_kW || data.avg_value_kW || 0.0;
    
    dailyProfileChart = new Chart(ctx.getContext('2d'), {
        type: 'line',
        data: {
            labels: hours.map(h => `${h}:00`),
            datasets: [
                {
                    label: 'Durchschnittliche Last (kW)',
                    data: power,
                    borderColor: 'rgba(59, 130, 246, 1)',
                    backgroundColor: 'rgba(59, 130, 246, 0.1)',
                    borderWidth: 2,
                    fill: true,
                    tension: 0.3
                },
                {
                    label: 'Gesamtdurchschnitt',
                    data: Array(24).fill(overallAvg),
                    borderColor: 'rgba(99, 102, 241, 0.8)',
                    borderWidth: 2,
                    borderDash: [5, 5],
                    fill: false,
                    pointRadius: 0,
                    pointHoverRadius: 0,
                    tension: 0
                }
            ]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
                x: {
                    title: {
                        display: true,
                        text: 'Stunde des Tages'
                    }
                },
                y: {
                    title: {
                        display: true,
                        text: 'Leistung (kW)'
                    },
                    beginAtZero: true
                }
            },
            plugins: {
                legend: {
                    display: true,
                    position: 'top'
                }
            }
        }
    });
}

// Globale Variable für Wochentags-Daten (für Wochenauswahl)
let weekdayAnalysisData = null;

function renderWeekdayChart(data) {
    const ctx = document.getElementById('weekdayChart');
    if (!ctx) return;
    
    // Daten speichern für Wochenauswahl
    weekdayAnalysisData = data;
    
    // Alten Chart zerstören falls vorhanden
    if (weekdayChart) {
        weekdayChart.destroy();
    }
    
    // Wochenauswahl-Dropdown befüllen (wenn mehrere Wochen vorhanden)
    const weekSelector = document.getElementById('weekdayWeekSelector');
    const weekSelect = document.getElementById('weekSelect');
    
    if (weekSelector && weekSelect && data.weeks && Object.keys(data.weeks).length > 1) {
        // Mehrere Wochen vorhanden - Dropdown anzeigen
        weekSelector.classList.remove('hidden');
        
        // Optionen befüllen
        weekSelect.innerHTML = '<option value="all">Alle Wochen (Gesamt)</option>';
        Object.keys(data.weeks).forEach((weekKey, index) => {
            const week = data.weeks[weekKey];
            if (week && week.week_label) {
                const option = document.createElement('option');
                option.value = weekKey;
                option.textContent = `Woche ${index + 1}: ${week.week_label}`;
                weekSelect.appendChild(option);
            }
        });
    } else if (weekSelector) {
        // Nur eine Woche oder keine Wochen-Daten - Dropdown verstecken
        weekSelector.classList.add('hidden');
    }
    
    // Standard: Alle Wochen anzeigen
    updateWeekdayChart();
}

function updateWeekdayChart() {
    if (!weekdayAnalysisData) {
        console.warn('⚠️ Keine Wochentags-Daten verfügbar für updateWeekdayChart()');
        return;
    }
    
    const ctx = document.getElementById('weekdayChart');
    if (!ctx) {
        console.warn('⚠️ weekdayChart Canvas-Element nicht gefunden');
        return;
    }
    
    const weekSelect = document.getElementById('weekSelect');
    const selectedWeek = weekSelect ? weekSelect.value : 'all';
    
    const weekdayNames = ['Montag', 'Dienstag', 'Mittwoch', 'Donnerstag', 'Freitag', 'Samstag', 'Sonntag'];
    
    let meanValues, maxValues, workdayAvg, weekendAvg, overallAvg;
    
    if (selectedWeek === 'all' || !weekdayAnalysisData.weeks || !weekdayAnalysisData.weeks[selectedWeek]) {
        // Alle Wochen (Gesamt)
        meanValues = weekdayNames.map(name => {
            if (weekdayAnalysisData.weekdays && weekdayAnalysisData.weekdays[name]) {
                return weekdayAnalysisData.weekdays[name].mean_kW || 0.0;
            }
            return 0.0;
        });
        
        maxValues = weekdayNames.map(name => {
            if (weekdayAnalysisData.weekdays && weekdayAnalysisData.weekdays[name]) {
                return weekdayAnalysisData.weekdays[name].max_kW || 0.0;
            }
            return 0.0;
        });
        
        workdayAvg = weekdayAnalysisData.workday_avg_kW || 0.0;
        weekendAvg = weekdayAnalysisData.weekend_avg_kW || 0.0;
        overallAvg = weekdayAnalysisData.overall_avg_kW || 0.0;
    } else {
        // Spezifische Woche
        const weekData = weekdayAnalysisData.weeks[selectedWeek];
        meanValues = weekdayNames.map(name => {
            if (weekData.weekdays && weekData.weekdays[name]) {
                return weekData.weekdays[name].mean_kW || 0.0;
            }
            return 0.0;
        });
        
        maxValues = weekdayNames.map(name => {
            if (weekData.weekdays && weekData.weekdays[name]) {
                return weekData.weekdays[name].max_kW || 0.0;
            }
            return 0.0;
        });
        
        workdayAvg = weekData.workday_avg_kW || 0.0;
        weekendAvg = weekData.weekend_avg_kW || 0.0;
        overallAvg = meanValues.reduce((a, b) => a + b, 0) / meanValues.length;
    }
    
    // Info-Box aktualisieren
    const infoDiv = document.getElementById('weekdayInfo');
    if (infoDiv) {
        const daysWithoutData = weekdayNames.filter((name, idx) => meanValues[idx] === 0 && maxValues[idx] === 0);
        let missingDaysInfo = '';
        if (daysWithoutData.length > 0) {
            missingDaysInfo = `<div class="col-span-2 md:col-span-3 mt-2 p-2 bg-yellow-50 border border-yellow-200 rounded text-sm">
                <span class="font-semibold text-yellow-800">⚠️ Keine Daten für:</span> 
                <span class="text-yellow-700">${daysWithoutData.join(', ')}</span>
            </div>`;
        }
        
        const weekendDrop = workdayAvg > 0 ? ((1 - weekendAvg / workdayAvg) * 100).toFixed(1) : 0.0;
        infoDiv.innerHTML = `
            <div class="grid grid-cols-2 md:grid-cols-3 gap-4">
                <div>
                    <span class="font-semibold">Werktage Ø:</span> ${workdayAvg.toFixed(2)} kW
                </div>
                <div>
                    <span class="font-semibold">Wochenende Ø:</span> ${weekendAvg.toFixed(2)} kW
                </div>
                <div>
                    <span class="font-semibold">Wochenende-Drop:</span> ${weekendDrop}%
                </div>
            </div>
            ${missingDaysInfo}
        `;
    }
    
    // Alten Chart zerstören falls vorhanden
    if (weekdayChart) {
        weekdayChart.destroy();
    }
    
    weekdayChart = new Chart(ctx.getContext('2d'), {
        type: 'bar',
        data: {
            labels: weekdayNames,
            datasets: [
                {
                    label: 'Durchschnitt (kW)',
                    data: meanValues,
                    backgroundColor: 'rgba(34, 197, 94, 0.6)',
                    borderColor: 'rgba(34, 197, 94, 1)',
                    borderWidth: 1
                },
                {
                    label: 'Maximum (kW)',
                    data: maxValues,
                    backgroundColor: 'rgba(239, 68, 68, 0.6)',
                    borderColor: 'rgba(239, 68, 68, 1)',
                    borderWidth: 1
                },
                {
                    label: 'Gesamtdurchschnitt',
                    data: Array(7).fill(overallAvg),
                    type: 'line',
                    borderColor: 'rgba(99, 102, 241, 0.8)',
                    borderWidth: 2,
                    borderDash: [5, 5],
                    fill: false,
                    pointRadius: 0,
                    pointHoverRadius: 0,
                    tension: 0
                }
            ]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
                x: {
                    title: {
                        display: true,
                        text: 'Wochentag'
                    }
                },
                y: {
                    title: {
                        display: true,
                        text: 'Leistung (kW)'
                    },
                    beginAtZero: true,
                    // Sicherstellen, dass auch 0-Werte sichtbar sind
                    ticks: {
                        min: 0,
                        stepSize: 10
                    }
                }
            },
            plugins: {
                legend: {
                    display: true,
                    position: 'top'
                },
                tooltip: {
                    callbacks: {
                        label: function(context) {
                            const value = context.parsed.y;
                            if (value === 0) {
                                return `${context.dataset.label}: 0 kW (keine Daten)`;
                            }
                            return `${context.dataset.label}: ${value.toFixed(2)} kW`;
                        }
                    }
                }
            }
        }
    });
}

function renderSeasonalChart(data) {
    updateSeasonalChart();
}

function updateSeasonalChart() {
    if (!currentAnalysisData || !currentAnalysisData.analyses || !currentAnalysisData.analyses.seasonal_analysis) {
        return;
    }
    
    const data = currentAnalysisData.analyses.seasonal_analysis;
    const ctx = document.getElementById('seasonalChart');
    if (!ctx) return;
    
    // Alten Chart zerstören falls vorhanden
    if (seasonalChart) {
        seasonalChart.destroy();
    }
    
    const seasonalViewSelect = document.getElementById('seasonalViewSelect');
    if (!seasonalViewSelect) return;
    const viewType = seasonalViewSelect.value;
    
    let labels, meanValues, maxValues, minValues;
    
    if (viewType === 'monthly') {
        const monthNames = ['Januar', 'Februar', 'März', 'April', 'Mai', 'Juni',
                           'Juli', 'August', 'September', 'Oktober', 'November', 'Dezember'];
        labels = monthNames;
        meanValues = monthNames.map(name => (data.monthly && data.monthly[name]) ? data.monthly[name].mean_kW : 0.0);
        maxValues = monthNames.map(name => (data.monthly && data.monthly[name]) ? data.monthly[name].max_kW : 0.0);
        minValues = monthNames.map(name => (data.monthly && data.monthly[name]) ? data.monthly[name].min_kW : 0.0);
    } else {
        const quarterNames = ['Q1 (Jan-Mär)', 'Q2 (Apr-Jun)', 'Q3 (Jul-Sep)', 'Q4 (Okt-Dez)'];
        labels = quarterNames;
        meanValues = quarterNames.map(name => (data.quarterly && data.quarterly[name]) ? data.quarterly[name].mean_kW : 0.0);
        maxValues = quarterNames.map(name => (data.quarterly && data.quarterly[name]) ? data.quarterly[name].max_kW : 0.0);
        minValues = quarterNames.map(name => (data.quarterly && data.quarterly[name]) ? data.quarterly[name].min_kW : 0.0);
    }
    
    // Info-Box aktualisieren
    const infoDiv = document.getElementById('seasonalInfo');
    if (infoDiv && data) {
        const winterAvg = data.winter_avg_kW || 0.0;
        const summerAvg = data.summer_avg_kW || 0.0;
        const seasonalVar = data.seasonal_variation_percent || 0.0;
        infoDiv.innerHTML = `
            <div class="grid grid-cols-2 md:grid-cols-3 gap-4">
                <div>
                    <span class="font-semibold">Winter Ø:</span> ${winterAvg.toFixed(2)} kW
                </div>
                <div>
                    <span class="font-semibold">Sommer Ø:</span> ${summerAvg.toFixed(2)} kW
                </div>
                <div>
                    <span class="font-semibold">Saisonale Variation:</span> ${seasonalVar.toFixed(1)}%
                </div>
            </div>
        `;
    }
    
    // Gesamtdurchschnitt für Trendlinie
    const overallAvg = data.overall_avg_kW || 0.0;
    
    // Alten Chart zerstören falls vorhanden
    if (seasonalChart) {
        seasonalChart.destroy();
    }
    
    seasonalChart = new Chart(ctx.getContext('2d'), {
        type: 'bar',
        data: {
            labels: labels,
            datasets: [
                {
                    label: 'Durchschnitt (kW)',
                    data: meanValues,
                    backgroundColor: 'rgba(245, 158, 11, 0.6)',
                    borderColor: 'rgba(245, 158, 11, 1)',
                    borderWidth: 1
                },
                {
                    label: 'Maximum (kW)',
                    data: maxValues,
                    backgroundColor: 'rgba(239, 68, 68, 0.6)',
                    borderColor: 'rgba(239, 68, 68, 1)',
                    borderWidth: 1
                },
                {
                    label: 'Minimum (kW)',
                    data: minValues,
                    backgroundColor: 'rgba(59, 130, 246, 0.6)',
                    borderColor: 'rgba(59, 130, 246, 1)',
                    borderWidth: 1
                },
                {
                    label: 'Gesamtdurchschnitt',
                    data: Array(labels.length).fill(overallAvg),
                    type: 'line',
                    borderColor: 'rgba(99, 102, 241, 0.8)',
                    borderWidth: 2,
                    borderDash: [5, 5],
                    fill: false,
                    pointRadius: 0,
                    pointHoverRadius: 0,
                    tension: 0
                }
            ]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
                x: {
                    title: {
                        display: true,
                        text: viewType === 'monthly' ? 'Monat' : 'Quartal'
                    }
                },
                y: {
                    title: {
                        display: true,
                        text: 'Leistung (kW)'
                    },
                    beginAtZero: true
                }
            },
            plugins: {
                legend: {
                    display: true,
                    position: 'top'
                }
            }
        }
    });
}
</script>
{% endblock %} 